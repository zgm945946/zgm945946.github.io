<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="1205">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="1205">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Baozi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>1205</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="1205" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">1205</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第一章 网络概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：18:59:58" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第五章 网络层控制平面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：19:01:43" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第5章：网络层控制平面"><a href="#第5章：网络层控制平面" class="headerlink" title="第5章：网络层控制平面"></a>第5章：网络层控制平面</h1><blockquote>
<p>本章目标：理解网络层控制平面的工作原理<br> 传统路由选择算法<br> SDN 控制器<br> ICMP:Internet Control Message Protocol<br> 网络管理（略） </p>
<p>以及它们在互联网上的实例和实现:<br> OSPF, BGP, OpenFlow, ODL 和ONOS控制器, ICMP, SNMP</p>
</blockquote>
<h1 id="5-1-导论"><a href="#5-1-导论" class="headerlink" title="5.1 导论"></a>5.1 导论</h1><h2 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h2><p>回顾:2个网络层功能:</p>
<ul>
<li><strong>转发:将分组从路由器的一数据平面</strong><br><strong>个输入端口移到合适的输出端口</strong></li>
<li><strong>路由:确定分组从源到目标控制平面的路径</strong></li>
</ul>
<p>2种构建网络控制平面功能的方法:</p>
<ul>
<li><p><strong>每个路由器控制功能实现（传统)</strong></p>
</li>
<li><p><strong>逻辑上集中的控制功能实现(software defined networking)</strong></p>
</li>
</ul>
<h3 id="传统方式：每-路由器-Per-router-控制平面"><a href="#传统方式：每-路由器-Per-router-控制平面" class="headerlink" title="传统方式：每-路由器(Per-router)控制平面"></a>传统方式：每-路由器(Per-router)控制平面</h3><p>在每一个路由器中的单独路由器算法元件，在控制平面进行 交互</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001182236954.png" alt="image-20211001182236954"></p>
<h3 id="SDN方式：逻辑上集中的控制平面"><a href="#SDN方式：逻辑上集中的控制平面" class="headerlink" title="SDN方式：逻辑上集中的控制平面"></a>SDN方式：逻辑上集中的控制平面</h3><p>一个不同的（通常是远程的）控制器与本地控制代理（CAs） 交互.</p>
<p>上发状态，下发流表</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001182317151.png" alt="image-20211001182317151"></p>
<h1 id="5-2-路由选择算法"><a href="#5-2-路由选择算法" class="headerlink" title="5.2 路由选择算法"></a>5.2 路由选择算法</h1><p> link state  distance vector</p>
<h2 id="路由-route-的概念"><a href="#路由-route-的概念" class="headerlink" title="路由(route)的概念"></a>路由(route)的概念</h2><ul>
<li><strong>路由:按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径</strong> <ul>
<li>较好路径: 按照某种指标较小的路径 </li>
<li>指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均 </li>
<li>采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视 </li>
</ul>
</li>
<li><p><strong>以网络为单位进行路由（路由信息通告+路由计算）</strong>   <strong>==一个子网 一个子网 进行路由==</strong></p>
<ul>
<li>网络为单位进行路由，路由信息传输、计算和匹配的代价低 </li>
<li>前提条件是：一个网络所有节点地址前缀相同，且物理上聚集 </li>
<li>路由就是：计算网络 到其他网络如何走的问题</li>
</ul>
</li>
<li><p><strong>网络到网络的路由= 路由器-路由器之间路由</strong> </p>
<ul>
<li>网络对应的路由器  到  其他网络对应的路由器的路由 </li>
<li><strong>在一个网络中：路由器-主机之间的通信，链路层解决</strong> </li>
</ul>
</li>
<li>到了这个路由器就是到了这个网络</li>
</ul>
<h3 id="网络的图抽象"><a href="#网络的图抽象" class="headerlink" title="网络的图抽象"></a>网络的图抽象</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001184712732.png" alt="image-20211001184712732"></p>
<p>==<strong>N = 路由器集合 = { u, v, w, x, y, z }</strong>==<br>==<strong>E = 链路集合 ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) } 边有代价</strong>==</p>
<h3 id="图抽象：边和路径的代价"><a href="#图抽象：边和路径的代价" class="headerlink" title="图抽象：边和路径的代价"></a>图抽象：边和路径的代价</h3><p>• c(x,x’) = 链路的代价 (x,x’) - e.g., c(w,z) = 5<br>•代价可能总为１<br>•或是 链路带宽的倒数<br>•或是 拥塞情况的倒数</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001184806495.png" alt="image-20211001184806495"></p>
<p>路由的输入：拓扑、边的代价、源节点<br>输出的输出：源节点的汇集树</p>
<h3 id="最优化原则-optimality-principle"><a href="#最优化原则-optimality-principle" class="headerlink" title="最优化原则(optimality principle)"></a>最优化原则(optimality principle)</h3><ul>
<li>汇集树(sink tree)    ——  Dijkstra算法、Bellman-Ford算法<ul>
<li><strong>此节点到所有其它节点的最优路径形成的树</strong>        <strong>==(源节点)==</strong>    到源节点的最短距离</li>
<li><strong>路由选择算法就是为所有路由器找到并使用汇集树</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001184954715.png" alt="image-20211001184954715"></p>
<h2 id="路由的原则"><a href="#路由的原则" class="headerlink" title="路由的原则"></a>路由的原则</h2><p>路由选择算法的原则 </p>
<ul>
<li>正确性(correctness):算法必须是正确的和完整的,使分 组一站一站接力，正确发向目标站；完整：目标所有的 站地址，在路由表中都能找到相应的表项；没有处理不 了的目标站地址； </li>
<li>简单性(simplicity):算法在计算机上应简单：最优但复杂 的算法，时间上延迟很大，不实用，不应为了获取路由 信息增加很多的通信量； </li>
<li>健壮性(robustness):算法应能适应通信量和网络拓扑的 变化：通信量变化，网络拓扑的变化算法能很快适应； 不向很拥挤的链路发数据，不向断了的链路发送数据；</li>
<li>稳定性(stability)：产生的路由不应该摇摆 </li>
<li>公平性(fairness)：对每一个站点都公平 </li>
<li>最优性(optimality)：某一个指标的最优，时间上，费用 上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ul>
<h3 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h3><p>全局或者局部路由信息?</p>
<p>全局:<br> 所有的路由器拥有完整的拓和边的代价的信息<br> <strong>==“link state” 算法==</strong> </p>
<p>分布式:<br> 路由器只知道与它有物理连接 关系的邻居路由器，和到相应 邻居路由器的代价值<br> 叠代地与邻居交换路由信息、 计算路由信息<br> <strong>==“distance vector” 算法==</strong></p>
<p>静态或者动态的?</p>
<ul>
<li><strong>静态:</strong><br><strong> 路由随时间变化缓慢</strong><br><strong>非自适应算法(non-adaptive algorithm)： 不能适应网络拓扑和通信量的变化,路由表是事先计算好的</strong></li>
<li><strong>动态:</strong><br><strong> 路由变化很快</strong><br><strong> 周期性更新</strong><br><strong> 根据链路代价的变化而变化</strong><br><strong>自适应路由选择(adaptive algorithm)：能适应网络拓扑和通信量的变化</strong>   ——    网络拓扑状态和边的代价状态</li>
</ul>
<h2 id="路由选择算法-link-state-（全局）"><a href="#路由选择算法-link-state-（全局）" class="headerlink" title="路由选择算法 link state （全局）"></a>路由选择算法 link state （全局）</h2><h3 id="LS路由的工作过程"><a href="#LS路由的工作过程" class="headerlink" title="LS路由的工作过程"></a>LS路由的工作过程</h3><p>配置LS路由选择算法的路由工作过程 </p>
<ul>
<li>各点通过各种渠道获得整个网络拓扑, 网络中所有链路代价等信息<strong>（这部分和算法没关系，属于协议和实现）</strong> </li>
<li>使用LS路由算法,计算本站点到其它站点的最优路径(汇集树),得到路由表</li>
<li>按照此路由表转发分组(datagram方式) <ul>
<li>严格意义上说不是路由的一个步骤 </li>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001224205074.png" alt="image-20211001224205074"></p>
<h3 id="链路状态路由选择-link-state-routing"><a href="#链路状态路由选择-link-state-routing" class="headerlink" title="链路状态路由选择(link state routing)"></a>链路状态路由选择(link state routing)</h3><p>LS路由的基本工作过程 </p>
<ol>
<li><p><strong>发现相邻节点,获知对方网络地址</strong> </p>
</li>
<li><p><strong>测量到相邻节点的代价(延迟,开销)</strong> </p>
</li>
<li><p><strong>组装一个LS分组,描述它到相邻节点的代价情况</strong> </p>
</li>
<li><p><strong>将分组通过扩散的方法发到所有其它路由器 以上4步让每个路由器获得拓扑和边代价</strong> </p>
</li>
<li><p><strong>通过Dijkstra算法找出最短路径（这才是路由算法）</strong> </p>
<ol>
<li><p>每个节点独立算出来到其他节点（路由器=网络）的最 短路径 </p>
</li>
<li><p>迭代算法：第k步能够知道本节点到k个其他节点的最 短路径</p>
</li>
</ol>
</li>
</ol>
<p>==<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a>  —— 类似泛洪  FloodFill 算法==</p>
<ol>
<li>发现相邻节点,获知对方网络地址<br> <strong>一个路由器上电之后,向所有线路发送HELLO分组</strong><br> <strong>其它路由器收到HELLO分组,回送应答,在应答分组中,告知自己的名字(全局唯一)</strong><br> <strong>在LAN中,通过广播HELLO分组,获得其它路由器的信息, 可以认为引入一个人工节点</strong></li>
</ol>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001224742043.png" alt="image-20211001224742043"></p>
<ol>
<li><p>测量到相邻节点的代价(延迟,开销)<br> <strong>实测法,发送一个分组要求对方立即响应</strong><br> 回送一个ECHO分组<br> 通过测量时间可以估算出延迟情况</p>
</li>
<li><p>组装一个分组,描述相邻节点的情况<br> <strong>发送者名称</strong><br> 序号,年龄<br> 列表: 给出它相邻节点,和它到相邻节点的延迟</p>
</li>
</ol>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001230058910.png" alt="image-20211001230058910"></p>
<ol>
<li><p>将分组通过扩散的方法发到所有其它路由器 </p>
<ul>
<li><p><strong>顺序号:用于控制无穷的扩散,每个路由器都记录( 源路由器,顺序号),发现重复的或老的就不扩散</strong> </p>
<ul>
<li>具体问题1: 循环使用问题 </li>
<li>具体问题2: 路由器崩溃之后序号从0开始 </li>
<li>具体问题3:序号出现错误 </li>
</ul>
</li>
<li><p><strong>解决问题的办法:年龄字段(age)</strong> </p>
<ul>
<li><strong>生成一个分组时,年龄字段不为0</strong> </li>
<li><strong>每个一个时间段,AGE字段减1</strong> </li>
<li><strong>AGE字段为0的分组将被抛弃</strong></li>
</ul>
</li>
<li><p>关于扩散分组的数据结构<br> <strong>Source</strong> :从哪个节点收到LS分组<br> <strong>Seq,Age</strong>:序号,年龄<br> <strong>Send flags</strong>:发送标记,必须向指定的哪些相邻站点转发LS分组<br> <strong>ACK flags</strong>:本站点必须向哪些相邻站点发送应答<br> <strong>DATA</strong>:来自source站点的LS分组  </p>
</li>
<li><p>节点B的数据结构</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002003536511.png" alt="image-20211002003536511"></p>
</li>
</ul>
</li>
<li><p>通过Dijkstra算法找出最短路径 </p>
<ol>
<li>路由器获得各站点LS分组和整个网络的拓扑 </li>
<li>通过Dijkstra算法计算出到其它各路由器的最短 路径(汇集树) </li>
<li>将计算结果安装到路由表中</li>
</ol>
</li>
</ol>
<h3 id="LS路由选择算法的工作原理"><a href="#LS路由选择算法的工作原理" class="headerlink" title="LS路由选择算法的工作原理"></a>LS路由选择算法的工作原理</h3><ul>
<li><p>LS (link state) 的应用情况</p>
<ul>
<li>OSPF协议是一种LS协议,被用于Internet上 </li>
<li>IS-IS(intermediate system- intermediate system): 被用于Internet主干中, Netware </li>
</ul>
</li>
<li><p>符号标记:<br>c(i,j): 从节点i 到j链路代价(初始状态下非相邻节点之间的 链路代价为∞)<br>D(v): 从源节点到节点V的当前路径代价(节点的代价)<br>p(v): 从源到节点V的路径前序节点<br>N’: 当前已经知道最优路径的的节点集合(永久节点的集合)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002003950243.png" alt="image-20211002003950243"></p>
</li>
<li><p>LS路由选择算法的工作原理</p>
<ul>
<li>节点标记: 每一个节点使用(D(v),p(v)) 如： (3,B)标记 <ul>
<li>D(v)从源节点由已知最优路径到达本节点的距离 </li>
<li>P(v)前序节点来标注 </li>
</ul>
</li>
<li>2类节点 <ul>
<li>临时节点(tentative node) :还没有找到从源 节点到此节点的最优路径的节点 </li>
<li>永久节点(permanent node) N’:已经找到了从 源节点到此节点的最优路径的节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li> 初始化 <ul>
<li>除了源节点外,所有节点都为临时节点 </li>
<li>节点代价除了与源节点代价相邻的节点外,都为∞ </li>
</ul>
</li>
<li> <strong>从所有临时节点中找到一个节点代价最小的临时节点,将 之变成永久节点(当前节点)W   —— 选择</strong></li>
<li> <strong>对此节点的所有在临时节点集合中的邻节点(V)   —— 更新</strong><ul>
<li> 如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W) </li>
<li> 否则，不重新标注 </li>
</ul>
</li>
<li> <strong>开始一个新的循环  ——  循环</strong></li>
</ul>
<p>例子:</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002004447848.png" alt="image-20211002004447848"></p>
<p>Dijkstra算法的例子</p>
<p><img src="C:\Users\20662\AppData\Roaming\Typora\typora-user-images\image-20211002004517248.png" alt="image-20211002004517248"></p>
<h3 id="Dijkstra算法的讨论"><a href="#Dijkstra算法的讨论" class="headerlink" title="Dijkstra算法的讨论"></a>Dijkstra算法的讨论</h3><p>算法复杂度: n节点<br>     每一次迭代: 需要检查所有不在永久集合N中节点<br>     n(n+1)/2 次比较: O(n2 )<br>     有很有效的实现: O(nlogn)<br>可能的震荡：<br>     e.g.,链路代价=链路承载的流量<br>    路径改变次数过多</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002005838258.png" alt="image-20211002005838258"></p>
<h2 id="路由选择算法-distance-vector-（分布式）"><a href="#路由选择算法-distance-vector-（分布式）" class="headerlink" title="路由选择算法 distance vector （分布式）"></a>路由选择算法 distance vector （分布式）</h2><h3 id="距离矢量路由选择-distance-vector-routing"><a href="#距离矢量路由选择-distance-vector-routing" class="headerlink" title="距离矢量路由选择(distance vector routing)"></a>距离矢量路由选择(distance vector routing)</h3><p>动态路由算法之一</p>
<p>DV算法历史及应用情况 </p>
<ul>
<li>1957 Bellman, 1962 Ford Fulkerson </li>
<li>用于ARPANET, Internet(RIP) DECnet , Novell, ApplTalk </li>
</ul>
<p>距离矢量路由选择的基本思想          <strong>以每个点为中心 更新路由表</strong></p>
<ul>
<li>各路由器维护一张路由表,结构如图(其它代价) </li>
<li>各路由器与相邻路由器交换路由表(待续)    <strong>==邻居与邻居交换代价==</strong></li>
<li>根据获得的路由信息,更新路由表(待续)       ==<strong>每个节点算出代价值，改变路径，更新路由表</strong>==</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002010557843.png" alt="image-20211002010557843"></p>
<ul>
<li>代价及相邻节点间代价的获得 <ul>
<li><strong>跳数(hops), 延迟(delay),队列长度</strong> </li>
<li><strong>相邻节点间代价的获得：通过实测</strong> </li>
</ul>
</li>
<li>路由信息的更新 <ul>
<li><strong>根据实测 得到本节点A到相邻站点的代价（如:延迟）</strong> </li>
<li><strong>根据各相邻站点声称它们到目标站点B的代价</strong> </li>
<li><strong>计算出本站点A经过各相邻站点到目标站点B的代价</strong> </li>
<li><strong>找到一个最小的代价，和相应的下一个节点Z，到达节点 B经过此节点Z，并且代价为A-Z-B的代价</strong> </li>
<li><strong>其它所有的目标节点同样的计算方法</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002010843273.png" alt="image-20211002010843273"></p>
<h3 id="距离矢量路由：例子1"><a href="#距离矢量路由：例子1" class="headerlink" title="距离矢量路由：例子1"></a>距离矢量路由：例子1</h3><ul>
<li>以当前节点J为例,相邻节点 A,I,H,K </li>
<li>J测得到A,I,H,K的延迟为 8ms,10ms,12ms,6ms </li>
<li>通过交换DV, 从A,I,H,K获得到 它们到G的延迟为 18ms,31ms,6ms,31ms </li>
<li>因此从J经过A,I,H,K到G的延迟 为26ms,41ms,18ms, 37ms </li>
<li>将到G的路由表项更新为18ms, 下一跳为：H </li>
<li>其它目标一样，除了本节点J</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012113751.png" alt="image-20211002012113751"></p>
<h3 id="距离矢量算法"><a href="#距离矢量算法" class="headerlink" title="距离矢量算法"></a>距离矢量算法</h3><p>递归风车</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012204557.png" alt="image-20211002012204557"></p>
<h3 id="Bellman-Ford例子"><a href="#Bellman-Ford例子" class="headerlink" title="Bellman-Ford例子"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14x411H7x9?from=search&amp;seid=2324818079252436290&amp;spm_id_from=333.337.0.0">Bellman-Ford例子</a></h3><p>SPFA —— 优化后的Bellman-Ford</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012336956.png" alt="image-20211002012336956"></p>
<ul>
<li>Dx (y) = 节点x到y代价最小值的估计 <ul>
<li>x 节点维护距离矢量Dx = [Dx (y): y є N ] </li>
</ul>
</li>
<li>节点x: <ul>
<li>知道到所有邻居v的代价: c(x,v) </li>
<li>收到并维护一个它邻居的距离矢量集 </li>
<li>对于每个邻居, x 维护 Dv = [Dv (y): y є N ]</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012514899.png" alt="image-20211002012514899"></p>
<h3 id="距离矢量算法特点和问题"><a href="#距离矢量算法特点和问题" class="headerlink" title="距离矢量算法特点和问题"></a>距离矢量算法特点和问题</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012604939.png" alt="image-20211002012604939"></p>
<ul>
<li><p>DV的无穷计算问题 </p>
<ul>
<li>DV的特点 <ul>
<li>好消息传的快 坏消息传的慢 </li>
</ul>
</li>
<li>好消息的传播以每一个交换周期前进一个路由器 的速度进行 <ul>
<li>好消息:某个路由器接入或有更短的路径 </li>
<li>举例<br><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012712585.png" alt="image-20211002012712585"></li>
</ul>
</li>
</ul>
</li>
<li><p>DV的无穷计算问题 </p>
<ul>
<li>坏消息的传播速度非常慢(无穷计算问题)</li>
<li>例子:<ul>
<li>第一次交换之后, B从C处获得信息,C可以到达A(C-A, 要经过B本身),但是路径是2,因此B变成3,从C处走 </li>
<li>第二次交换,C从B处获得消息, B可以到达A,路径为3, 因此,C到A从B走,代价为3 </li>
<li>无限此之后, 到A的距离变成INF,不可达</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002012915419.png" alt="image-20211002012915419"></p>
<h3 id="水平分裂-split-horizon-算法"><a href="#水平分裂-split-horizon-算法" class="headerlink" title="水平分裂(split horizon)算法"></a>水平分裂(split horizon)算法</h3><ul>
<li>一种对无穷计算问题的解决办法  —— 结局坏消息传的慢的问题<ul>
<li><strong>C知道要经过B才能到达A，所以C向B报告它到A的距离 为INF；C 告诉D它到A的真实距离</strong> </li>
<li>D告诉E,它到A的距离,但D告诉C它通向A的距离为INF </li>
<li>第一次交换: B通过测试发现到A的路径为INF,而C也告 诉B到A的距离为INF,因此,B到A的距离为INF </li>
<li>第二次交换: C从B和D那里获知,到A的距离为INF,因此 将它到A的距离为INF </li>
<li>……坏消息以一次交换一个节点的速度传播</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002112809523.png" alt="image-20211002112809523"></p>
<p>告诉B 无穷，D真实值</p>
<h3 id="距离矢量算法例子"><a href="#距离矢量算法例子" class="headerlink" title="距离矢量算法例子"></a>距离矢量算法例子</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002113230006.png" alt="image-20211002113230006"></p>
<h2 id="LS-和-DV-算法的比较"><a href="#LS-和-DV-算法的比较" class="headerlink" title="LS 和 DV 算法的比较"></a>LS 和 DV 算法的比较</h2><p><strong>消息复杂度（DV胜出）</strong>  O(NE)</p>
<p><strong>收敛时间（LS胜出）</strong>       O(NlogN)</p>
<p><strong>健壮性（LS胜出）</strong>    节点之间影响较小</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002113320727.png" alt="image-20211002113320727"></p>
<h1 id="5-3-因特网中自治系统内部的路由选择-实际的、内部的"><a href="#5-3-因特网中自治系统内部的路由选择-实际的、内部的" class="headerlink" title="5.3 因特网中自治系统内部的路由选择 (实际的、内部的)"></a>5.3 因特网中自治系统内部的路由选择 (实际的、内部的)</h1><h2 id="RIP-Routing-Information-Protocol"><a href="#RIP-Routing-Information-Protocol" class="headerlink" title="RIP ( Routing Information Protocol)"></a>RIP ( Routing Information Protocol)</h2><p>在 1982年发布的BSD-UNIX 中实现 </p>
<ul>
<li><strong>==Distance vector 算法==</strong> </li>
<li>距离矢量:每条链路cost=1，# of hops (max = 15 hops) 跳数 </li>
<li>DV每隔30秒和邻居交换DV，通告 </li>
<li>每个通告包括：最多25个目标子网</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002144643968.png" alt="image-20211002144643968"></p>
<h3 id="RIP-通告（advertisements）"><a href="#RIP-通告（advertisements）" class="headerlink" title="RIP 通告（advertisements）"></a>RIP 通告（advertisements）</h3><ul>
<li>DV: 在邻居之间每30秒交换通告报文 <ul>
<li>定期，而且在改变路由的时候发送通告报文 </li>
<li>在对方的请求下可以发送通告报文 </li>
</ul>
</li>
<li>每一个通告: 至多AS内部的25个目标网络的 DV <ul>
<li>目标网络+跳数<br>一次公告最多25个 子网 最大跳数为16 </li>
</ul>
</li>
</ul>
<h3 id="RIP-例子"><a href="#RIP-例子" class="headerlink" title="RIP: 例子"></a>RIP: 例子</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002161034218.png" alt="image-20211002161034218"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002161049443.png" alt="image-20211002161049443"></p>
<h3 id="RIP-链路失效和恢复"><a href="#RIP-链路失效和恢复" class="headerlink" title="RIP: 链路失效和恢复"></a>RIP: 链路失效和恢复</h3><p>如果180秒没有收到通告信息—&gt;邻居或者链路失效 </p>
<ul>
<li>发现经过这个邻居的路由已失效 </li>
<li>新的通告报文会传递给邻居 </li>
<li>邻居因此发出新的通告 (如果路由变化的话) </li>
<li>链路失效快速(?)地在整网中传输 </li>
<li>使用毒性逆转（poison reverse）阻止ping-pong回路 ( 不可达的距离：跳数无限 = 16 段)</li>
</ul>
<h3 id="RIP-进程处理"><a href="#RIP-进程处理" class="headerlink" title="RIP 进程处理"></a>RIP 进程处理</h3><ul>
<li>RIP 以应用进程的方式实现：route-d (daemon) </li>
<li>通告报文通过UDP报文传送，周期性重复 </li>
<li>网络层的协议使用了传输层的服务，以应用层实体的 方式实现</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002161616471.png" alt="image-20211002161616471"></p>
<h2 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF (Open Shortest Path First)"></a>OSPF (Open Shortest Path First)</h2><ul>
<li>“open”: 标准可公开获得 </li>
<li>==<strong>使用LS算法</strong>== <ul>
<li>LS 分组在网络中（一个AS内部）分发 </li>
<li>全局网络拓扑、代价在每一个节点中都保持 </li>
<li>路由计算采用Dijkstra算法 </li>
</ul>
</li>
<li>OSPF通告信息中携带：每一个邻居路由器一个表项 </li>
<li>通告信息会传遍AS全部（通过泛洪） <ul>
<li>在IP数据报上直接传送OSPF报文 (而不是通过UDP和TCP) </li>
</ul>
</li>
<li>IS-IS路由协议：几乎和OSPF一样</li>
</ul>
<h3 id="OSPF-“高级”-特性-在RIP中的没有的"><a href="#OSPF-“高级”-特性-在RIP中的没有的" class="headerlink" title="OSPF “高级” 特性(在RIP中的没有的)"></a>OSPF “高级” 特性(在RIP中的没有的)</h3><ul>
<li>安全:所有的OSPF报文都是经过认证的(防止恶意的攻击)</li>
<li>允许有多个代价相同的路径存在(在RIP协议中只有一个)</li>
<li>对于每一个链路，对于不同的TOS有多重代价矩阵<ul>
<li>例如:卫星链路代价对于尽力而为的服务代价设置比较低，对实<br>时服务代价设置的比较高</li>
<li>支持按照不同的代价计算最优路径，如:按照时间和延迟分别计<br>算最优路径</li>
</ul>
</li>
<li>对单播和多播的集成支持:<ul>
<li>Multicast OSPF(MOSPF)使用相同的拓扑数据库，就像在OSPF中一样</li>
</ul>
</li>
<li>在大型网络中支持层次性OSPF</li>
</ul>
<h3 id="层次化的OSPF路由"><a href="#层次化的OSPF路由" class="headerlink" title="层次化的OSPF路由"></a>层次化的OSPF路由</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002170733474.png" alt="image-20211002170733474"></p>
<h3 id="层次性的OSPF路由"><a href="#层次性的OSPF路由" class="headerlink" title="层次性的OSPF路由"></a>层次性的OSPF路由</h3><ul>
<li>2个级别的层次性: 本地, 骨干 <ul>
<li>链路状态通告仅仅在本地区域Area范围内进行 </li>
<li>每一个节点拥有本地区域的拓扑信息； </li>
</ul>
</li>
<li>关于其他区域，知道去它的方向，通过区域边界路 由器（最短路径） </li>
<li>区域边界路由器: “汇总（聚集）”到自己区域 内网络的距离, 向其它区域边界路由器通告. </li>
<li>骨干路由器: 仅仅在骨干区域内，运行OSPF路由 </li>
<li>边界路由器: 连接其它的AS’s.</li>
</ul>
<h1 id="5-4-ISP之间的路由选择-BGP"><a href="#5-4-ISP之间的路由选择-BGP" class="headerlink" title="5.4 ISP之间的路由选择: BGP"></a>5.4 ISP之间的路由选择: BGP</h1><h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>一个平面的路由 </p>
<ul>
<li>一个网络中的所有路 由器的地位一样 </li>
<li>通过LS, DV，或者其 他路由算法，所有路 由器都要知道其他所 有路由器（子网）如 何走 </li>
<li>所有路由器在一个平 面</li>
</ul>
<p>平面路由的问题 </p>
<ul>
<li><strong>规模巨大的网络中，路由信息的存储、传输和计算代价 巨大</strong><ul>
<li>DV: 距离矢量很大，且不能够 收敛 </li>
<li>LS：几百万个节点的LS分组 的泛洪传输，存储以及最短路 径算法的计算 </li>
</ul>
</li>
<li><strong>管理问题：</strong>  （一个平面搞不定）<ul>
<li>不同的网络所有者希望按照自 己的方式管理网络 </li>
<li>希望对外隐藏自己网络的细节 </li>
<li>当然，还希望和其它网络互联</li>
</ul>
</li>
</ul>
<h3 id="层次路由的实现"><a href="#层次路由的实现" class="headerlink" title="层次路由的实现"></a>层次路由的实现</h3><ul>
<li><p>层次路由：将互联网 分成一个个AS(路由器 区域) </p>
<ul>
<li><strong>某个区域内的路由器集 合，自治系统 “autonomous systems” (AS)</strong> </li>
<li>一个AS用AS Number （ASN)唯一标示 </li>
<li>一个ISP可能包括1个 或者多个AS</li>
</ul>
</li>
<li><p>路由变成了: 2个层次路由 </p>
<ul>
<li><strong>AS内部路由：在同一个AS 内路由器运行相同的路由协议</strong><ul>
<li>“intra-AS” routing protocol：内部网关协议 </li>
<li>不同的AS可能运行着不同的 内部网关协议 </li>
<li>能够解决规模和管理问题 </li>
<li>如：RIP,OSPF,IGRP </li>
<li>网关路由器：AS边缘路由器 ，可以连接到其他AS </li>
</ul>
</li>
<li><strong>AS间运行AS间路由协议</strong> <ul>
<li><strong>“inter-AS” routing protocol：外部网关协议</strong> </li>
<li><strong>解决AS之间的路由问题，完成AS之间的互联互通</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="层次路由的优点"><a href="#层次路由的优点" class="headerlink" title="层次路由的优点"></a>层次路由的优点</h3><ul>
<li>解决了<strong>规模问题</strong><ul>
<li><strong>内部网关协议解决:AS内部数量有限的路由器相互到达的间题，AS内部规模可控</strong><ul>
<li>如AS节点太多，可分割AS，使得AS内部的节点数量有限</li>
</ul>
</li>
<li>AS之间的路由的规模问题<ul>
<li>增加一个As，对于AS之间的路由从总体上来说，只是增加了一个节点=子网(每个AS可以用一个点来表示)</li>
<li>对于其他AS来说只是增加了一个表项，就是这个新增的AS如何走的问题</li>
<li><strong>扩展性强:规模增大，性能不会减得太多</strong></li>
</ul>
</li>
</ul>
</li>
<li>解决了<strong>管理问题</strong> <ul>
<li><strong>各个AS可以运行不 同的内部网关协议</strong> </li>
<li><strong>可以使自己网络的细节不向外透露</strong></li>
</ul>
</li>
</ul>
<h2 id="互联网AS间路由：BGP-边界网关协议"><a href="#互联网AS间路由：BGP-边界网关协议" class="headerlink" title="互联网AS间路由：BGP 边界网关协议"></a>互联网AS间路由：BGP 边界网关协议</h2><ul>
<li>BGP (Border Gateway Protocol):自治区域间路由协议”事实上的”标准<br>o <strong>“将互联网各个AS粘在一起的胶水”</strong></li>
<li>BGP提供给每个AS以以下方法:<br>o <strong>eBGP:从相邻的ASes那里获得子网可达信息</strong> —— 从外部获取<br>o <strong>iBGP:将获得的子网可达信息传遍到AS内部的所有路由器</strong>  —— 向内部传<br>o <strong>根据子网可达信息和策略来决定到达子网的”好”路径</strong></li>
<li>允许子网向互联网其他网络通告”我在这里”</li>
<li>基于距离矢量算法(路径矢量)<br>o不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS<br>序号的列表）能够避免简单DV算法的路由环路问题</li>
</ul>
<h3 id="eBGP-iBGP-连接"><a href="#eBGP-iBGP-连接" class="headerlink" title="eBGP, iBGP 连接"></a>eBGP, iBGP 连接</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002172739773.png" alt="image-20211002172739773"></p>
<h1 id="5-5-SDN控制平面"><a href="#5-5-SDN控制平面" class="headerlink" title="5.5 SDN控制平面"></a>5.5 SDN控制平面</h1><h2 id="Software-defined-networking-SDN"><a href="#Software-defined-networking-SDN" class="headerlink" title="Software defined networking (SDN)"></a>Software defined networking (SDN)</h2><ul>
<li> 互联网络网络层：历史上都是通过分布式、每个 路由器的实现 <ul>
<li> 单个路由器包含了：交换设备硬件、私有路由器OS（ 如：思科IOS）和其上运行的互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现 </li>
<li> 需要不同的中间盒来实现不同网络层功能：防火墙， 负载均衡设备和NAT…</li>
</ul>
</li>
</ul>
<h2 id="SDN-面临的挑战"><a href="#SDN-面临的挑战" class="headerlink" title="SDN: 面临的挑战"></a>SDN: 面临的挑战</h2><ul>
<li>强化控制平面：可信、可靠、性能可扩展性、 安全的分布式系统 <ul>
<li>对于失效的鲁棒性： 利用为控制平面可靠分布式系 统的强大理论 </li>
<li>可信任，安全：从开始就进行铸造 </li>
</ul>
</li>
<li>网络、协议满足特殊任务的需求 <ul>
<li>e.g., 实时性，超高可靠性、超高安全性 </li>
</ul>
</li>
<li>互联网络范围内的扩展性 <ul>
<li>而不是仅仅在一个AS的内部部署，全网部署</li>
</ul>
</li>
</ul>
<h1 id="5-6-ICMP-因特网控制报-文协议"><a href="#5-6-ICMP-因特网控制报-文协议" class="headerlink" title="5.6 ICMP: 因特网控制报 文协议"></a>5.6 ICMP: 因特网控制报 文协议</h1><h2 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP: Internet Control Message Protocol"></a>ICMP: Internet Control Message Protocol</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002173250939.png" alt="image-20211002173250939"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002173303211.png" alt="image-20211002173303211"></p>
<h1 id="5-7-网络管理和SNMP-略）"><a href="#5-7-网络管理和SNMP-略）" class="headerlink" title="5.7 网络管理和SNMP(略）"></a>5.7 网络管理和SNMP(略）</h1><h2 id="什么是网络管理"><a href="#什么是网络管理" class="headerlink" title="什么是网络管理?"></a>什么是网络管理?</h2><p>自治系统（autonomous systems, aka “network”): 1000多个 相互的软件和硬件部件 </p>
<p>其他复杂系统也需要被监视和控制:  喷气飞机  核电站  其他例子？</p>
<blockquote>
<p>“网络管理”包括了硬件、软件和人类元素的设置，综合和协 调，以便监测，测试，轮询，配置，分析，评价和控制网络 和网元资源，用合理的成本满足实时性，运行能和服务质量 的要求；</p>
</blockquote>
<p>性能管理:<br>О性能(利用率、吞吐量)量化、测量、报告、分析和控制不同网络部件的性能<br>o 涉及到的部件:单独部件（网卡，协议实体），端到端的路径故障管理:记录、检测和响应故障;<br>○ 性能管理为长期监测设备性能</p>
<p>故障管理:突然发生的强度大的性能降低，强调对故障的响应配置管理:跟踪设备的配置，管理设备配置信息</p>
<p>账户管理:定义、记录和控制用户和设备访问网络资源<br>o限额使用、给予使用的收费，以及分配资源访问权限</p>
<p>安全管理:定义安全策略，控制对网络资源的使用</p>
<h2 id="网络管理架构"><a href="#网络管理架构" class="headerlink" title="网络管理架构"></a>网络管理架构</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002173448692.png" alt="image-20211002173448692"></p>
<h2 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002173459816.png" alt="image-20211002173459816"></p>
<h3 id="SNMP-协议-报文类型"><a href="#SNMP-协议-报文类型" class="headerlink" title="SNMP 协议: 报文类型"></a>SNMP 协议: 报文类型</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002173514916.png" alt="image-20211002173514916"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002173523394.png" alt="image-20211002173523394"></p>
<h1 id="第五章：总结"><a href="#第五章：总结" class="headerlink" title="第五章：总结"></a>第五章：总结</h1><ul>
<li>网络层控制平面的方法<br>o<strong>==每个路由器控制（传统方法)==</strong><br>o<strong>==逻辑上集中的控制(software defined networking)==</strong>   SDN</li>
<li>传统路由选择算法<br>o<strong>==在互联网上的实现:RIP，OSPF，BGP==</strong></li>
<li>SDN控制器<br>o <strong>==实际中的实现:ODL,ONOS==</strong></li>
<li>Internet Control Message Protocol</li>
<li>网络管理和SNMP协议</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第四章 网络层:数据平面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：19:01:02" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第-4-章-网络层：数据平面"><a href="#第-4-章-网络层：数据平面" class="headerlink" title="第 4 章 网络层：数据平面"></a>第 4 章 网络层：数据平面</h1><p>本章目标:<br> 理解网络服务的基本原理，聚焦于其<strong>数据平面</strong><br>     <strong>网络服务模型</strong><br>     <strong>转发和路由</strong><br>     <strong>路由器工作原理</strong><br>     <strong>通用转发</strong><br> 互联网中网络层协议的实例和实现</p>
<p>[TOC]</p>
<h1 id="4-1-导论"><a href="#4-1-导论" class="headerlink" title="4.1 导论"></a>4.1 导论</h1><p> 数据平面<br> 控制平面</p>
<h2 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h2><p> 在发送主机和接收主机对之间 传送段<strong>（segment）</strong><br> 在发送端将段封装到数据报中<br> 在接收端，将段上交给传输层 实体<br> 网络层协议存在于每一个主机 和路由器<br> 路由器检查每一个经过它的IP 数据报的头部</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001100723126.png" alt="image-20211001100723126" style="zoom:80%;" /></p>
<h2 id="网络层的关键功能"><a href="#网络层的关键功能" class="headerlink" title="网络层的关键功能"></a>网络层的关键功能</h2><p>网络层功能：<br> 转发: 将分组从路由器的输入接口转发到合适的输出接口<br> 路由: 使用路由算法来决定分组从发送主机到目标接收主机的路径<br>    路由选择算法<br>    路由选择协议</p>
<p><strong>旅行的类比：</strong> </p>
<ul>
<li><strong>转发: 通过单个路口的过程</strong>  —— 数据平面</li>
<li><strong>路由: 从源到目的的路由路径规划过程</strong> —— 控制平面</li>
</ul>
<h2 id="网络层：数据平面、控制平面"><a href="#网络层：数据平面、控制平面" class="headerlink" title="网络层：数据平面、控制平面"></a>网络层：数据平面、控制平面</h2><ul>
<li><p>数据平面 </p>
<ul>
<li>本地，每个路由器功能 </li>
<li><strong>决定从路由器输入端口到达的分组如何转发到输出端口</strong> </li>
<li>转发功能： <ul>
<li>传统方式：基于目标 地址+转发表 </li>
<li><strong>SDN方式：基于多个字段+流表</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>控制平面 </p>
<ul>
<li>网络范围内的逻辑 </li>
<li><strong>决定数据报如何在路由器之间 路由，决定数据报从源到目标主机之间的端到端路径</strong> </li>
<li>2个控制平面方法: <ul>
<li><strong>==传统的路由算法: 在路由器中被实现  —— 功能单一：根据目标的IP地址进行转发==</strong></li>
<li><strong>==software-defined networking (SDN): 在远程的服务器中实现==</strong><br>软件定义网   ——   匹配很多字段，功能更多：泛洪、转发、修改字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传统方式：每-路由器-Per-router-控制平面"><a href="#传统方式：每-路由器-Per-router-控制平面" class="headerlink" title="传统方式：每-路由器(Per-router)控制平面"></a>传统方式：每-路由器(Per-router)控制平面</h3><p><strong>==在每一个路由器中的单独路由器算法元件，在控制平面进行交互==</strong><br><strong>紧耦合，难以修改</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001102609192.png" alt="image-20211001102609192"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001102633237.png" alt="image-20211001102633237"></p>
<h3 id="SDN方式：逻辑集中的控制平面"><a href="#SDN方式：逻辑集中的控制平面" class="headerlink" title="SDN方式：逻辑集中的控制平面"></a>SDN方式：逻辑集中的控制平面</h3><p><u><strong>==一个不同的（通常是远程的）控制器与本地控制代理（CAs） 交互==</strong></u><br>网络操作系统运行在集中的控制器上</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001102716772.png" alt="image-20211001102716772"></p>
<h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><p>Q: 从发送方主机到接收方主机传输数据报的“通道” ，网络提供什么样的服务模型？</p>
<ul>
<li>对于单个数据报的服务: <ul>
<li>可靠传送 </li>
<li>延迟保证，如：少于 40ms的延迟</li>
</ul>
</li>
<li>对于数据报流的服务: <ul>
<li>保序数据报传送 </li>
<li>保证流的最小带宽 </li>
<li>分组之间的延迟差</li>
</ul>
</li>
</ul>
<h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p> 在某些网络架构中是第三个重要的功能<br>     ATM, frame relay, X.25 </p>
<p> 在分组传输之前，在两个主机之间，在通过一些 路由器所构成的路径上建立一个网络层连接<br>     涉及到路由器 </p>
<p> <strong>网络层和传输层连接服务区别:</strong><br>     <strong>网络层: 在2个主机之间，涉及到路径上的一些路由器</strong>  —— 有连接<br>     <strong>传输层: 在2个进程之间，很可能只体现在端系统上 (TCP连接)</strong>  —— 面向连接</p>
<h3 id="一些网络层服务模型"><a href="#一些网络层服务模型" class="headerlink" title="一些网络层服务模型"></a>一些网络层服务模型</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001103624022.png" alt="image-20211001103624022"></p>
<h1 id="4-2-路由器组成"><a href="#4-2-路由器组成" class="headerlink" title="4.2 路由器组成"></a>4.2 路由器组成</h1><h2 id="路由器结构概况-传统"><a href="#路由器结构概况-传统" class="headerlink" title="路由器结构概况 (传统)"></a>路由器结构概况 (传统)</h2><p>高层面(非常简化的)通用路由器体系架构 </p>
<ul>
<li>路由：运行路由选择算法／协议 (RIP, OSPF, BGP) - 生成 路由表 </li>
<li>转发：从输入到输出链路交换数据报 - 根据路由表进行分组的转发</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001103919273.png" alt="image-20211001103919273"></p>
<h2 id="输入端口功能"><a href="#输入端口功能" class="headerlink" title="输入端口功能"></a>输入端口功能</h2><p>输入端口有个队列</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001104327835.png" alt="image-20211001104327835"></p>
<h3 id="输入端口缓存"><a href="#输入端口缓存" class="headerlink" title="输入端口缓存"></a>输入端口缓存</h3><ul>
<li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队 <ul>
<li><strong>==排队延迟以及由于输入缓存溢出造成丢失!==</strong> </li>
</ul>
</li>
<li>Head-of-the-Line (HOL) blocking: 排在队头的数据报 阻止了队列中其他数据报向前移动</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001104653702.png" alt="image-20211001104653702"></p>
<h2 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h2><p> 将分组从输入缓冲区传输到合适的输出端口<br> 交换速率：分组可以按照该速率从输入传输到输 出<br>     运行速度经常是输入/输出链路速率的若干倍<br>     N 个输入端口：交换机构的交换速度是输入线路速度的N倍比较理 想，才不会成为瓶颈<br> 3种典型的交换机构</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001104817961.png" alt="image-20211001104817961"></p>
<h3 id="通过内存交换"><a href="#通过内存交换" class="headerlink" title="通过内存交换"></a>通过内存交换</h3><p>第一代路由器:</p>
<ul>
<li>在CPU直接控制下的交换，采用传统的计算机</li>
<li><strong>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</strong></li>
<li><strong>转发速率被内存的带宽限制(数据报通过BUS两遍)</strong></li>
<li>一次只能转发一个分组</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001104907438.png" alt="image-20211001104907438"></p>
<h3 id="通过总线交换"><a href="#通过总线交换" class="headerlink" title="通过总线交换"></a>通过总线交换</h3><ul>
<li>数据报通过共享总线，从输入端 <ul>
<li>转发到输出端口 </li>
</ul>
</li>
<li><strong>总线竞争: 交换速度受限于总线带宽</strong> </li>
<li>1次处理一个分组 </li>
<li>1 Gbps bus, Cisco 1900； 32 Gbps bus, Cisco 5600；<br>对于接 入或企业级路由器，速度足够（ 但不适合区域或骨干网络）</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001104959142.png" alt="image-20211001104959142"></p>
<h3 id="通过互联网络-crossbar等-的交换"><a href="#通过互联网络-crossbar等-的交换" class="headerlink" title="通过互联网络(crossbar等)的交换"></a>通过互联网络(crossbar等)的交换</h3><p><strong>同时并发转发多个分组，克服总线带宽限制</strong></p>
<ul>
<li>Banyan(榕树〉网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口Y;控制器短接相应的两个总线</li>
<li>高级设计:将数据报分片为固定长度的信元，通过交换网络交换</li>
<li>Cisco12000:以60Gbps的交换速率通过互联网络</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001105151671.png" alt="image-20211001105151671"></p>
<h2 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001105403564.png" alt="image-20211001105403564"></p>
<p> 当数据报从交换机构的到达速度比传输速率快 就需要输出端口缓存 </p>
<p> 由调度规则选择排队的数据报进行传输</p>
<p>优先权调度-谁会获得最优性能， 网络中立？</p>
<h3 id="输出端口排队"><a href="#输出端口排队" class="headerlink" title="输出端口排队"></a>输出端口排队</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001105440439.png" alt="image-20211001105440439"></p>
<ul>
<li>假设交换速率Rswitch是Rline的N倍（N：输入端口的数量） </li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通 过交换网络到达的速率超过输出速率则缓存） </li>
<li><strong>排队带来延迟，由于输出端口缓存溢出则丢弃数据报！</strong></li>
</ul>
<h3 id="需要多少缓存"><a href="#需要多少缓存" class="headerlink" title="需要多少缓存?"></a>需要多少缓存?</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001105910410.png" alt="image-20211001105910410"></p>
<h2 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h2><p><strong>调度: 选择下一个要通过链路传输的分组</strong> </p>
<ul>
<li>FIFO (first in first out) scheduling: 按照分组到来的次序发送 <ul>
<li>现实例子? </li>
<li>丢弃策略: 如果分组到达一个满的队列，哪个分组将会 被抛弃? <ul>
<li>tail drop: 丢弃刚到达的分组 </li>
<li>priority: 根据优先权丢失/移除分组 </li>
<li>random: 随机地丢弃/移除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="调度策略：优先权"><a href="#调度策略：优先权" class="headerlink" title="调度策略：优先权"></a>调度策略：优先权</h3><p>优先权调度：发送最高优先 权的分组 </p>
<ul>
<li>多类，不同类别有不同的 优先权 <ul>
<li>类别可能依赖于标记或者其 他的头部字段, e.g. IP source/dest, port numbers, ds，etc. </li>
<li>先传高优先级的队列中的分 组，除非没有 </li>
<li>高（低）优先权中的分组传 输次序：FIFO </li>
<li>现实生活中的例子? </li>
</ul>
</li>
</ul>
<p>有红的不传绿的</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001110210112.png" alt="image-20211001110210112"></p>
<h3 id="调度策略：其他的"><a href="#调度策略：其他的" class="headerlink" title="调度策略：其他的"></a>调度策略：其他的</h3><p>Round Robin (RR) scheduling:<br> 多类<br> <strong>循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类</strong><br> 现实例子?</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001111117490.png" alt="image-20211001111117490"></p>
<p>Weighted Fair Queuing (WFQ):<br> 一般化的Round Robin<br> <strong>在一段时间内，每个队列得到的服务时间是：  Wi /(XIGMA(Wi )) *t ，和权重成正比</strong><br> 每个类在每一个循环中获得不同权重的服务量<br> 现实例子</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001111153165.png" alt="image-20211001111153165"></p>
<h1 id="4-3-IP-Internet-Protocol"><a href="#4-3-IP-Internet-Protocol" class="headerlink" title="4.3 IP: Internet Protocol"></a>4.3 IP: Internet Protocol</h1><p>ICMP（Internet Control Message Protocol）Internet控制<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/报文/3164352">报文</a>协议</p>
<p>互联网的网络层<br>主机,路由器中的网络层功能：</p>
<p>IP协议主要实现的是数据平面的转发功能</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001111457486.png" alt="image-20211001111457486"></p>
<h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001111652067.png" alt="image-20211001111652067"></p>
<p>、</p>
<p><strong>==16-bit identifier        flgs        fragment offset        ——        分片/重组使用==</strong></p>
<h2 id="IP-分片和重组-Fragmentation-amp-Reassembly"><a href="#IP-分片和重组-Fragmentation-amp-Reassembly" class="headerlink" title="IP 分片和重组(Fragmentation &amp; Reassembly)"></a>IP 分片和重组(Fragmentation &amp; Reassembly)</h2><ul>
<li><strong>网络链路有MTU (最大传输单元) –链路层帧所携带的最大数据长度</strong> <ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42248536/article/details/88819222">不同的链路类型</a>  —— <strong>Access链路</strong>、<strong>Trunk链路</strong>、</li>
<li>不同的MTU </li>
</ul>
</li>
<li>大的IP数据报在网络上被分片 (“fragmented”)<ul>
<li>一个数据报被分割成若干个小 的数据报 <ul>
<li>相同的ID </li>
<li>不同的偏移量 </li>
<li>最后一个分片标记为0 </li>
</ul>
</li>
<li>“重组”只在最终的目标主机进行 </li>
<li>IP头部的信息被用于标识，排序相关分片</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001133625648.png" alt="image-20211001133625648"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001133700562.png" alt="image-20211001133700562"></p>
<p>flagflag —— 标识后面还有没有</p>
<h2 id="IP-编址-引论"><a href="#IP-编址-引论" class="headerlink" title="IP 编址: 引论"></a>IP 编址: 引论</h2><ul>
<li>IP 地址: 32位标示，对 主机或者路由器的接口编址 </li>
<li>接口: 主机/路由器和物 理链路的连接处 <ul>
<li>路由器通常拥有多个接口 </li>
<li>主机也有可能有多个接口 </li>
<li>IP地址和每一个接口关联 </li>
</ul>
</li>
<li>一个IP地址和一个接口相关联</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001135955479.png" alt="image-20211001135955479"></p>
<h3 id="子网-Subnets"><a href="#子网-Subnets" class="headerlink" title="子网(Subnets)"></a>子网(Subnets)</h3><ul>
<li><strong>IP地址:</strong> <ul>
<li>子网部分(高位bits) </li>
<li>主机部分(低位bits) </li>
</ul>
</li>
<li><strong>什么是子网(subnet) ?</strong> <ul>
<li><strong>一个子网内的节点（主 机或者路由器）它们的 IP地址的高位部分相同 ，这些节点构成的网络的一部分叫做子网</strong> </li>
<li><strong>无需路由器介入，子网内各主机可以在物理上相互直接到达</strong>   ——   只需要交换机即可，一跳可达</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001142106457.png" alt="image-20211001142106457"></p>
<p><strong>长途链路 —— 点到点的形式   中国到日本的链路</strong><br><strong>计算机局域网  ——  多点连接的方式</strong></p>
<p>方法：<br> <strong>要判断一个子网, 将每一个接口从主机或者路由 器上分开,构成了一个个网络的孤岛</strong><br> <strong>每一个孤岛（网络）都 是一个都可以被称之为 subnet.</strong></p>
<p>子网掩码：11111111 11111111 11111111 00000000<br>Subnet mask: /24</p>
<h3 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h3><p> Class A：126 networks ，16 million hosts<br> Class B：16382networks ，64 K hosts<br> Class C：2 million networks ，254 host<br> Class D：multicast<br> Class E：reserved for future<br>全0全1不用</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001142823822.png" alt="image-20211001142823822"></p>
<h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><ul>
<li>一些约定：<ul>
<li><strong>子网部分: 全为 0—-本网络</strong>       <strong>127   Loopback —— 回路地址</strong></li>
<li><strong>主机部分: 全为0—-本主机</strong> </li>
<li><strong>主机部分: 全为1—广播地址，这个网络的所有主机</strong> </li>
<li>除了前面的类号   <strong>全为1——在本地网络广播</strong></li>
</ul>
</li>
<li>特殊IP地址</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001142922347.png" alt="image-20211001142922347"></p>
<h3 id="内网-专用-IP地址"><a href="#内网-专用-IP地址" class="headerlink" title="内网(专用)IP地址"></a>内网(专用)IP地址</h3><ul>
<li><strong>专用地址：地址空间的一部份供专用地址使用</strong> </li>
<li>永远不会被当做公用地址来分配, 不会与公用地址重复 <ul>
<li>只在局部网络中有意义，区分不同的设备 </li>
</ul>
</li>
<li><strong>路由器不对目标地址是专用地址的分组进行转发</strong> </li>
<li>专用地址范围 <ul>
<li><strong>Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0</strong> </li>
<li><strong>Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0</strong> </li>
<li><strong>Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0</strong></li>
</ul>
</li>
</ul>
<h3 id="IP-编址-CIDR"><a href="#IP-编址-CIDR" class="headerlink" title="IP 编址: CIDR"></a>IP 编址: CIDR</h3><p>CIDR: Classless InterDomain Routing （无类域间路由） </p>
<ul>
<li>子网部分可以在任意的位置 </li>
<li>地址格式: a.b.c.d/x, 其中 x 是 地址中子网号的长度</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001143934822.png" alt="image-20211001143934822"></p>
<h3 id="子网掩码-subnet-mask"><a href="#子网掩码-subnet-mask" class="headerlink" title="子网掩码(subnet mask)"></a>子网掩码(subnet mask)</h3><ul>
<li>32bits ,0 or 1 in each bito <ul>
<li>1: bit位置表示子网部分</li>
<li>0:bit位置表示主机部分</li>
</ul>
</li>
<li>原始的A、B、C类网络的子网掩码分别是<ul>
<li>A:255.0.0.0 : 11111111 00000000 00000000 00000000</li>
<li>B:255,255.0.0:11111111 11111111 0000000 00000000</li>
<li>C:255,255,255.0:11111111 11111111 11111111 00000000</li>
</ul>
</li>
<li>CIDR下的子网掩码例子:<ul>
<li>1111111111111111 11111100 0o0000oo</li>
</ul>
</li>
<li>另外的一种表示子网掩码的表达方式<ul>
<li>/#</li>
<li>例:/22:表示前面22个bit为子网部分</li>
</ul>
</li>
</ul>
<h3 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001144206732.png" alt="image-20211001144206732"></p>
<ul>
<li>获得IP数据报的目标地址 </li>
<li>对于转发表中的每一个表项 <ul>
<li>如 (IP Des addr) &amp; (mask)== destination, 则按照表项 对应的接口转发该数据报 </li>
<li>如果都没有找到,则使用默认表项转发数据报</li>
</ul>
</li>
</ul>
<h2 id="如何获得一个IP地址-主机"><a href="#如何获得一个IP地址-主机" class="headerlink" title="如何获得一个IP地址   主机"></a>如何获得一个IP地址   主机</h2><p>Q: 主机如何获得一个IP地址?</p>
<ul>
<li>系统管理员将地址配置在一个文件中 <ul>
<li>Wintel: control-panel-&gt;network- &gt;configuration-&gt;tcp/ip-&gt;properties </li>
<li>UNIX: /etc/rc.config</li>
</ul>
</li>
<li><strong>DHCP: Dynamic Host Configuration Protocol: 从服务器中动态获得一个IP地址</strong> <ul>
<li>“plug-and-play</li>
</ul>
</li>
</ul>
<h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP: Dynamic Host Configuration Protocol"></a>DHCP: Dynamic Host Configuration Protocol</h3><ul>
<li>目标:允许主机在加入网络的时候，动态地从服务器那里获得IP地址:<ul>
<li><strong>可以更新对主机在用IP地址的租用期-租期快到了</strong></li>
<li><strong>重新启动时，允许重新使用以前用过的IP地址</strong></li>
<li><strong>支持移动用户加入到该网络（短期在网）</strong></li>
</ul>
</li>
<li>DHCP工作概况:<ul>
<li>主机广播“DHCP discover”报文[可选]</li>
<li>DHCP服务器用“DHCP offer”提供报文响应[可选]</li>
<li>主机请求IP地址:发送“DHCP request”报文</li>
<li>DHCP服务器发送地址:“DHCP ack”报文</li>
</ul>
</li>
</ul>
<h3 id="DHCP-client-server-scenario"><a href="#DHCP-client-server-scenario" class="headerlink" title="DHCP client-server scenario"></a>DHCP client-server scenario</h3><p><strong>第二次是因为可能有多个DHCP 服务器，要确认用哪一个</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001144822831.png" alt="image-20211001144822831"></p>
<h3 id="DHCP-不仅仅是IP-addresses"><a href="#DHCP-不仅仅是IP-addresses" class="headerlink" title="DHCP: 不仅仅是IP addresses"></a>DHCP: 不仅仅是IP addresses</h3><p>DHCP 返回: </p>
<ul>
<li>IP 地址 </li>
<li>第一跳路由器的IP地址（默认网关） </li>
<li>DNS服务器的域名和IP地址 </li>
<li>子网掩码 (指示地址部分的网络号和主机号)</li>
</ul>
<h3 id="DHCP-实例"><a href="#DHCP-实例" class="headerlink" title="DHCP: 实例"></a>DHCP: 实例</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001145225819.png" alt="image-20211001145225819"></p>
<p>第一次握手</p>
<p>联网笔记本需要获取自己的IP地址，第一跳路由器地址和DNS服务器:采用DHCP协议<br>DHCP请求被封装在UDP段中,封装在IP数据报中，封装在以太网的帧中<br>以太网帧在局域网范围内广播(dest: FFFFFFFFFFFF)<br>被运行DHCP服务的路由器收到<br>以太网帧解封装成IP，IP解封装成UDP，解封装成DHCP</p>
<p>DHCP服务器生成DHCP ACK,包含客户端的IP地址，第一跳路由器的IP地址和DNS域名服务器的IP地址<br>DHCP服务器封装的报文所在的帧转发到客户端，在客户端解封装成DHCP报文<br>客户端知道它自己的IP地址，DNS服务器的名字和IP地址，第一跳路由器的IP地址</p>
<p>第二次握手 略</p>
<h2 id="如何获得一个IP地址-机构"><a href="#如何获得一个IP地址-机构" class="headerlink" title="如何获得一个IP地址   机构"></a>如何获得一个IP地址   机构</h2><p>Q: 如何获得一个网络的子网部分?<br>A: 从ISP获得地址块中分配一个小地址块</p>
<p>ISP’s block 11001000 00010111 00010000 00000000 200.23.16.0/20<br>Organization 0 11001000 00010111 00010000 00000000 200.23.16.0/23<br>Organization 1 11001000 00010111 00010010 00000000 200.23.18.0/23<br>Organization 2 11001000 00010111 00010100 00000000 200.23.20.0/23<br>                                                        … ….. …. ….<br>Organization 7 11001000 00010111 00011110 00000000 200.23.30.0/23</p>
<h3 id="层次编址-路由聚集（route-aggregation）-聚集"><a href="#层次编址-路由聚集（route-aggregation）-聚集" class="headerlink" title="层次编址: 路由聚集（route aggregation）          聚集"></a>层次编址: 路由聚集（route aggregation）          聚集</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001145630149.png" alt="image-20211001145630149"></p>
<h3 id="层次编址-特殊路由信息-more-specific-routes"><a href="#层次编址-特殊路由信息-more-specific-routes" class="headerlink" title="层次编址: 特殊路由信息(more specific routes)"></a>层次编址: 特殊路由信息(more specific routes)</h3><p><strong>==匹配冲突时候，采取的是最长前缀匹配==</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001150738412.png" alt="image-20211001150738412"></p>
<h2 id="IP-编址-如何获得一块地址-ISP"><a href="#IP-编址-如何获得一块地址-ISP" class="headerlink" title="IP 编址: 如何获得一块地址 ISP"></a>IP 编址: 如何获得一块地址 ISP</h2><p>Q: 一个ISP如何获得一个地址块?<br>A: ICANN: Internet Corporation for Assigned Names and Numbers </p>
<ul>
<li>分配地址 </li>
<li>管理DNS </li>
<li>分配域名，解决冲突</li>
</ul>
<h2 id="NAT-Network-Address-Translation-网络地址转换-内网"><a href="#NAT-Network-Address-Translation-网络地址转换-内网" class="headerlink" title="NAT: Network Address Translation  网络地址转换(内网)"></a>NAT: Network Address Translation  网络地址转换(内网)</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001150949929.png" alt="image-20211001150949929"></p>
<ul>
<li>动机: 本地网络只有一个有效IP地址:        分配更多地址<ul>
<li><strong>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备—省钱</strong> </li>
<li><strong>可以在局域网改变设备的地址情况下而无须通知 外界</strong> </li>
<li><strong>可以改变ISP（地址变化）而不需要改变内部的 设备地址</strong> </li>
<li><strong>局域网内部的设备没有明确的地址，对外是不可 见的—安全</strong></li>
</ul>
</li>
</ul>
<p><strong>实现: NAT 路由器必须:</strong></p>
<ul>
<li><strong>==外出数据包：替换源地址和端口号为NAT IP地址 和新的端口号，==</strong><br>目标IP和端口不变 …远端的C/S将会用NAP IP地址，新端口号作为目标地址</li>
<li>记住每个转换替换对（在NAT转换表中）<br> ==<strong>.. 源IP，端口 vs NAP IP ，新端口</strong>== </li>
<li><strong>==进入数据包：替换目标IP地址和端口号，==</strong><br>采用存储在NAT表中的mapping表项，用（源IP，端口）</li>
</ul>
<p><strong>实际上就是用外网的某个IP代替内网里面的网络号，</strong><br><strong>出去的时候替换   原来IP 和 端口号</strong><br><strong>进来的时候替换    目标IP 和 端口号</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001152133538.png" alt="image-20211001152133538"></p>
<h3 id="NAT-穿越问题（略）"><a href="#NAT-穿越问题（略）" class="headerlink" title="NAT 穿越问题（略）"></a>NAT 穿越问题（略）</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001152533723.png" alt="image-20211001152533723"></p>
<ul>
<li><p>客户端需要连接地址为 10.0.0.1的服务器 </p>
<ul>
<li>服务器地址10.0.0.1 LAN本地地址 (客户端不能够使用其作为目标地址) </li>
<li>整网只有一个外部可见地址: 138.76.29.7 </li>
</ul>
</li>
<li><p><strong>方案1: 静态配置NAT：转发 进来的对服务器特定端口连接 请求</strong></p>
<ul>
<li>e.g., (123.76.29.7, port 2500) 总是转发到10.0.0.1 port 25000</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001152723380.png" alt="image-20211001152723380"></p>
</li>
<li><p><strong>方案2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许 NATted主机可以:</strong>    动态分配端口</p>
<ul>
<li> 获知网络的公共 IP地址 (138.76.29.7) </li>
<li> 列举存在的端口映射</li>
<li> 增/删端口映射 (在租用时间内 )</li>
</ul>
</li>
<li>i.e., 自动化静态NAT端口映射配 置</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001152732177.png" alt="image-20211001152732177"></p>
<ul>
<li><strong>方案 3: 中继 (used in Skype)</strong> <ul>
<li> NAT后面的服务器建立和中继的连接 </li>
<li> 外部的客户端链接到中继 </li>
<li> 中继在2个连接之间桥接</li>
</ul>
</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="IPv6：动机"><a href="#IPv6：动机" class="headerlink" title="IPv6：动机"></a>IPv6：动机</h3><ul>
<li>初始动机: 32-bit地址空间将会被很快用完 </li>
<li>另外的动机: <ul>
<li>头部格式改变帮助加速处理和转发 、<ul>
<li>TTL-1 </li>
<li>头部checksum </li>
<li>分片 </li>
</ul>
</li>
<li>头部格式改变帮助QoS </li>
</ul>
</li>
</ul>
<p>IPv6 数据报格式: </p>
<ul>
<li>固定的40 字节头部 </li>
<li>数据报传输过程中，不允许分片</li>
</ul>
<h3 id="IPv6-头部-Cont"><a href="#IPv6-头部-Cont" class="headerlink" title="IPv6 头部 (Cont)"></a>IPv6 头部 (Cont)</h3><p>Priority: 标示流中数据报的优先级<br>Flow Label: 标示数据报在一个“flow.” ( “flow”的概念没有被严格的定义)<br>Next header: 标示上层协议</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001153026504.png" alt="image-20211001153026504"></p>
<h3 id="和IPv4的其它变化"><a href="#和IPv4的其它变化" class="headerlink" title="和IPv4的其它变化"></a>和IPv4的其它变化</h3><ul>
<li>Checksum: 被移除掉，降低在每一段中的处理 速度 </li>
<li>Options: 允许，但是在头部之外, 被 “Next Header” 字段标示 </li>
<li>ICMPv6: ICMP的新版本 <ul>
<li>附加了报文类型, e.g. “Packet Too Big” </li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
<h3 id="从IPv4到IPv6的平移"><a href="#从IPv4到IPv6的平移" class="headerlink" title="从IPv4到IPv6的平移"></a>从IPv4到IPv6的平移</h3><ul>
<li>不是所有的路由器都能够同时升级的 <ul>
<li>没有一个标记日 “flag days” </li>
<li>在IPv4和IPv6路由器混合时，网络如何运转? </li>
</ul>
</li>
<li><strong>隧道: 在IPv4路由器之间传输的IPv4数据报中携 带IPv6数据报</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001153350960.png" alt="image-20211001153350960"></p>
<h3 id="隧道-Tunneling"><a href="#隧道-Tunneling" class="headerlink" title="隧道(Tunneling)"></a>隧道(Tunneling)</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001153500951.png" alt="image-20211001153500951"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001153521591.png" alt="image-20211001153521591"></p>
<h3 id="IPv6-应用"><a href="#IPv6-应用" class="headerlink" title="IPv6: 应用"></a>IPv6: 应用</h3><ul>
<li>Google: 8% 的客户通过IPv6访问谷歌服务</li>
<li>NIST: 全美国1/3的政府域支持IPv6 </li>
<li>估计还需要很长时间进行部署 <ul>
<li>20年以上! </li>
<li>看看过去20年来应用层面的变化: WWW, Facebook, streaming media, Skype, … </li>
<li>为什么?</li>
</ul>
</li>
</ul>
<h1 id="4-4-通用转发和SDN"><a href="#4-4-通用转发和SDN" class="headerlink" title="4.4 通用转发和SDN"></a>4.4 通用转发和SDN</h1><h2 id="网络层功能为例的数据平面和控制平面"><a href="#网络层功能为例的数据平面和控制平面" class="headerlink" title="网络层功能为例的数据平面和控制平面"></a>网络层功能为例的数据平面和控制平面</h2><p><strong>网络层功能：</strong> </p>
<ul>
<li>转发： 对于从某个端口 到来的分组转发到合适的 输出端口 </li>
<li>路由： 决定分组从源端 到目标端的路径 <ul>
<li>路由算法</li>
</ul>
</li>
</ul>
<p><strong>类比: 旅行</strong></p>
<ul>
<li>转发： 一个多岔路口的进入和转出过程 </li>
<li>路由: 规划从源到目标的旅行路径</li>
</ul>
<p><strong>数据平面</strong>    <strong>==细节==</strong></p>
<ul>
<li>本地的、每个路由器的 功能 </li>
<li>决定某个从某个端口进 入的分组从从哪个端口 输出 </li>
<li>转发功能</li>
</ul>
<p><strong>控制平面</strong>    ==<strong>整体</strong>==</p>
<ul>
<li>网络范围的逻辑 </li>
<li>决定分组端到端穿行于各个路 由器的路径</li>
</ul>
<h2 id="每个路由器-Per-Route-的控制平面-（传统）"><a href="#每个路由器-Per-Route-的控制平面-（传统）" class="headerlink" title="每个路由器(Per Route)的控制平面  （传统）"></a>每个路由器(Per Route)的控制平面  （传统）</h2><p><strong>每个路由器上都有实现路由算法元件（它们之间需要相互交 互）- 形成传统IP实现方式的控制平面</strong></p>
<p><strong>控制平面式分布式的，由各个路由器的各自完成，难于管理</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001154409133.png" alt="image-20211001154409133"></p>
<h3 id="数量众多、功能各异的中间盒"><a href="#数量众多、功能各异的中间盒" class="headerlink" title="数量众多、功能各异的中间盒"></a>数量众多、功能各异的中间盒</h3><ul>
<li>路由器的网络层功能： <ul>
<li>IP转发：对于到来的分组按照路由表决定如何转发，数 据平面 </li>
<li>路由：决定路径，计算路由表；处在控制平面 </li>
</ul>
</li>
<li>还有其他种类繁多网络设备（中间盒）： <ul>
<li>交换机；防火墙；NAT；IDS；负载均衡设备 </li>
<li>未来：不断增加的需求和相应的网络设备 </li>
<li><strong>需要不同的设备去实现不同的网络功能</strong> <ul>
<li><strong>每台设备集成了控制平面和数据平面的功能</strong> </li>
<li><strong>控制平面分布式地实现了各种控制平面功能</strong> </li>
<li><strong>升级和部署网络设备非常困难</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络设备控制平面的实现方式特点"><a href="#网络设备控制平面的实现方式特点" class="headerlink" title="网络设备控制平面的实现方式特点"></a>网络设备控制平面的实现方式特点</h3><ul>
<li><p><strong>==互联网网络设备：传统方式都是通过分布式，每台 备的方法来实现数据平面和控制平面功能==</strong> </p>
<ul>
<li>垂直集成：每台路由器或其他网络设备，包括： <ul>
<li>1）硬件、在私有的操作系统； </li>
<li>2）互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现 </li>
<li>从上到下都由一个厂商提供（代价大、被设备上“绑架”“） </li>
</ul>
</li>
<li>每个设备都实现了数据平面和控制平面的事情 <ul>
<li>控制平面的功能是分布式实现的 </li>
</ul>
</li>
<li>设备基本上只能（分布式升级困难）按照固定方式工作， 控制逻辑固化。不同的网络功能需要不同的 “middleboxes”：防火墙、负载均衡设备、NAT boxes, .</li>
</ul>
</li>
<li><p>（数据+控制平面）集成&gt;（控制逻辑）分布-&gt;固化 </p>
<ul>
<li>代价大；升级困难；管理困难等</li>
</ul>
</li>
</ul>
<h3 id="传统方式实现网络功能的问题"><a href="#传统方式实现网络功能的问题" class="headerlink" title="传统方式实现网络功能的问题"></a>传统方式实现网络功能的问题</h3><ul>
<li>问题： <ul>
<li><strong>垂直集成&gt;昂贵、不便于创新的生态</strong> </li>
<li><strong>分布式、固化设备功能==网络设备种类繁多</strong> <ul>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级 特性 </li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设 备：管理困难 </li>
<li>要增加新的网络功能，需要设计、实现以及部署新的 特定设备，设备种类繁多 </li>
</ul>
</li>
</ul>
</li>
<li>~2005: 开始重新思考网络控制平面的处理方式 <ul>
<li>集中：远程的控制器集中实现控制逻辑 </li>
<li>远程：数据平面和控制平面的分离</li>
</ul>
</li>
</ul>
<h2 id="SDN：逻辑上集中的控制平面-（新）"><a href="#SDN：逻辑上集中的控制平面-（新）" class="headerlink" title="SDN：逻辑上集中的控制平面 （新）"></a>SDN：逻辑上集中的控制平面 （新）</h2><p>一个不同的（通常是远程）控制器和CA交互，控制器决定分组 转发的逻辑（可编程），CA所在设备执行逻辑。</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001155320593.png" alt="image-20211001155320593"></p>
<h3 id="SDN的主要思路"><a href="#SDN的主要思路" class="headerlink" title="SDN的主要思路"></a>SDN的主要思路</h3><ul>
<li>网络设备数据平面和控制平面分离 </li>
<li>数据平面-分组交换机 <ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽 象成：按照流表（由控制平面设置的控制逻辑）进行PDU （帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻 塞） </li>
<li>统一化设备功能：SDN交换机（分组交换机），执行控制 逻辑 </li>
</ul>
</li>
<li>控制平面-控制器+网络应用 <ul>
<li>分离、集中 </li>
<li>计算和下发控制逻辑：流表</li>
</ul>
</li>
</ul>
<h3 id="SDN控制平面和数据平面分离的优势"><a href="#SDN控制平面和数据平面分离的优势" class="headerlink" title="SDN控制平面和数据平面分离的优势"></a>SDN控制平面和数据平面分离的优势</h3><ul>
<li><strong>水平集成控制平面</strong>的<strong>开放实现</strong>（而非私有实 现），创造出好的产业生态，促进发展 <ul>
<li>分组交换机、控制器和各种控制逻辑网络应用app可由不同 厂商生产，专业化，引入竞争形成良好生态 </li>
</ul>
</li>
<li><strong>集中式</strong>实现控制逻辑，网络<strong>管理容易</strong>： <ul>
<li>集中式控制器了解网络状况，编程简单，传统方式困难 </li>
<li>避免路由器的误配置 </li>
</ul>
</li>
<li><strong>基于流表的匹配+行动的工作方式允许“可编程的”分组交换机</strong> <ul>
<li>实现流量工程等高级特性 </li>
<li>在此框架下实现各种新型（未来）的网络设备</li>
</ul>
</li>
</ul>
<h3 id="类比-主框架到PC的演变"><a href="#类比-主框架到PC的演变" class="headerlink" title="类比: 主框架到PC的演变"></a>类比: 主框架到PC的演变</h3><p><strong>要买硬件 就要买操作系统  就要买专用的软件</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001155703049.png" alt="image-20211001155703049"></p>
<h2 id="流量工程-传统路由比较困难"><a href="#流量工程-传统路由比较困难" class="headerlink" title="流量工程: 传统路由比较困难"></a>流量工程: 传统路由比较困难</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001160320932.png" alt="image-20211001160320932"></p>
<p><strong>==Q: 网管如果需要u到z的流量走uvwz,x到z的流量走xwyz，怎么办？==</strong> </p>
<p>A: <strong>需要定义链路的代价</strong>，流量路由算法以此运算<strong>（ IP路由面向目标，无法操作）</strong> (或者需要新的路由算法)! </p>
<p>链路权重只是控制旋钮，错！</p>
<h3 id="流量工程：困难"><a href="#流量工程：困难" class="headerlink" title="流量工程：困难"></a>流量工程：困难</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001160555463.png" alt="image-20211001160555463"></p>
<p>Q: 如果网管需要将u到z的流量分成2路：uvwz 和uxyz ( 负载均衡)，怎么办?（IP路由面向目标） </p>
<p>A: 无法完成(在原有体系下只有使用新的路由选择算法 ，而在全网部署新的路由算法是个大的事情)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001160622576.png" alt="image-20211001160622576"></p>
<p>Q:如果需要w对蓝色的和红色的流量采用不同的路由，怎么办？ </p>
<p>A: 无法操作 (基于目标的转发，采用LS, DV 路由)</p>
<h3 id="SDN特点"><a href="#SDN特点" class="headerlink" title="SDN特点"></a>SDN特点</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001160657605.png" alt="image-20211001160657605"></p>
<h2 id="SDN-架构"><a href="#SDN-架构" class="headerlink" title="SDN 架构"></a>SDN 架构</h2><h3 id="SDN-架构-数据平面交换机"><a href="#SDN-架构-数据平面交换机" class="headerlink" title="SDN 架构: 数据平面交换机"></a>SDN 架构: 数据平面交换机</h3><p>数据平面交换机 </p>
<ul>
<li>快速，简单，商业化交换设备 采用硬件实现通用转发功能 </li>
<li>流表被控制器计算和安装 </li>
<li><strong>基于南向API（例如OpenFlow ），SDN控制器访问基于流的交换机</strong> <ul>
<li>定义了哪些可以被控制哪些不能 </li>
</ul>
</li>
<li>也定义了和控制器的协议 (e.g., OpenFlow)</li>
</ul>
<h3 id="SDN-架构-SDN控制器"><a href="#SDN-架构-SDN控制器" class="headerlink" title="SDN 架构: SDN控制器"></a>SDN 架构: SDN控制器</h3><p>SDN 控制器(网络OS): </p>
<ul>
<li>维护网络状态信息 </li>
<li><strong>通过上面的北向API和网络 控制应用交互</strong>   向上</li>
<li><strong>通过下面的南向API和网络 交换机交互</strong>       向下</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、 容错性以及鲁棒性采用分布式方法</li>
</ul>
<h3 id="SDN-架构-控制应用"><a href="#SDN-架构-控制应用" class="headerlink" title="SDN 架构: 控制应用"></a>SDN 架构: 控制应用</h3><p>网络控制应用: </p>
<ul>
<li>控制的大脑： 采用下层提供 的服务（SDN控制器提供的 API)，实现网络功能 <ul>
<li>路由器 交换机 </li>
<li>接入控制 防火墙 </li>
<li>负载均衡 </li>
<li>其他功能 </li>
</ul>
</li>
<li>非绑定：可以被第三方提供 ，与控制器厂商以通常上不 同，与分组交换机厂商也可 以不同</li>
</ul>
<h3 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h3><p>每个路由器包含一个流表（被逻辑上集中的控制器计算和分发）</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161538845.png" alt="image-20211001161538845"></p>
<h2 id="OpenFlow协议"><a href="#OpenFlow协议" class="headerlink" title="OpenFlow协议"></a>OpenFlow协议</h2><p>通用flow-bascd基于流的匹配+行动(c.g,DpcnFlow)</p>
<p><strong>OpenFlow</strong>，一种网络通信协议，属于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/数据链路层">数据链路层</a>，<strong>能够控制网上交换器或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/路由器">路由器</a>的转发平面（forwarding plane），借此改变网络数据包所走的网络路径。</strong></p>
<blockquote>
<p>OpenFlow能够启动远程的控制器，经由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/网络交换器/8534019">网络交换器</a>，决定网络数据包要由何种路径通过<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/网络交换机/2105356">网络交换机</a>。这个协议的发明者，将它当成<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/软件定义网络">软件定义网络</a>（Software-defined networking）的启动器。 [1] </p>
<p>OpenFlow允许从远程控制网络交换器的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/数据包">数据包</a>转送表，透过新增、修改与移除数据包控制规则与行动，来改变数据包转送的路径。比起用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/访问控制表">访问控制表</a>(ACLs) 和路由协议，允许更复杂的流量管理。同时，OpenFlow允许不同供应商用一个简单，开源的协议去远程管理交换机（通常提供专有的接口和描述语言）。</p>
<p>OpenFlow<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/协议">协议</a>用来描述控制器和交换机之间交互所用信息的标准，以及控制器和交换机的接口标准。协议的核心部分是用于OpenFlow协议信息结构的集合。</p>
<p>OpenFlow<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/协议支持">协议支持</a>三种信息类型：Controller-to-Switch，Asynchronous和Symmetric，每一个类型都有多个子类型。Controller-to-Switch信息由控制器发起并且直接用于检测交换机的状态。Asynchronous信息由交换机发起并通常用于更新控制器的网络事件和改变交换机的状态。Symmetric信息可以在没有请求的情况下由控制器或交换机发起。</p>
</blockquote>
<h3 id="OpenFlow-数据平面抽象"><a href="#OpenFlow-数据平面抽象" class="headerlink" title="OpenFlow 数据平面抽象"></a>OpenFlow 数据平面抽象</h3><ul>
<li><strong>流: 由分组（帧）头部字段所定义</strong> </li>
<li>通用转发: 简单的分组处理规则 <ul>
<li>模式: 将分组头部字段和流表进行匹配 </li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、 将匹配的分组发送给控制器 </li>
<li>优先权Priority: 几个模式匹配了，优先采用哪个，消除歧 义 </li>
<li>计数器Counters: #bytes 以及 #packets</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161610989.png" alt="image-20211001161610989"></p>
<h3 id="OpenFlow-流表的表项结构"><a href="#OpenFlow-流表的表项结构" class="headerlink" title="OpenFlow: 流表的表项结构"></a>OpenFlow: 流表的表项结构</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161724509.png" alt="image-20211001161724509"></p>
<h4 id="例子-基于目标的转发"><a href="#例子-基于目标的转发" class="headerlink" title="例子 基于目标的转发"></a>例子 基于目标的转发</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161743836.png" alt="image-20211001161743836"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161759335.png" alt="image-20211001161759335"></p>
<h3 id="OpenFlow-抽象"><a href="#OpenFlow-抽象" class="headerlink" title="OpenFlow 抽象"></a>OpenFlow 抽象</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161825639.png" alt="image-20211001161825639"></p>
<h4 id="OpenFlow-例子"><a href="#OpenFlow-例子" class="headerlink" title="OpenFlow 例子"></a>OpenFlow 例子</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211001161835426.png" alt="image-20211001161835426"></p>
<p>问题: 转发表(基于目标的转发)和 流表（通用转发）是如何计算出 来的？ 答案: 通过控制平面(下一章)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第三章 传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：19:00:15" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第3章-传输层"><a href="#第3章-传输层" class="headerlink" title="第3章 传输层"></a>第3章 传输层</h1><p>[TOC]</p>
<p>目标：<br> 理解传输层的工作原理<br>     多路复用/解复用<br>     可靠数据传输<br>     流量控制<br>     拥塞控制<br> 学习Internet的传输层协议<br>     UDP：无连接传输<br>     TCP：面向连接的可靠传 输<br>     TCP的拥塞控制</p>
<h2 id="3-1-概述和传输层服务"><a href="#3-1-概述和传输层服务" class="headerlink" title="3.1 概述和传输层服务"></a>3.1 概述和传输层服务</h2><p>传输服务和协议 </p>
<ul>
<li>为运行在不同主机上的应用进程提供逻辑通信 </li>
<li>传输协议运行在端系统 <ul>
<li>发送方：将应用层的报文分成报文段，然后传递给网络层 </li>
<li>接收方：将报文段重组成报文，然后传递给应用层 </li>
</ul>
</li>
<li>有多个传输层协议可供应用选择 <ul>
<li>Internet: TCP(字节流的服务，不保证界限) 和 UDP</li>
</ul>
</li>
</ul>
<h3 id="传输层-vs-网络层"><a href="#传输层-vs-网络层" class="headerlink" title="传输层 vs. 网络层"></a>传输层 vs. 网络层</h3><ul>
<li><p>网络层服务：主机之间的逻辑通信 </p>
</li>
<li><p>传输层服务：进程间的逻辑通信 </p>
<ul>
<li>依赖于网络层的服务 <ul>
<li>延时、带宽 </li>
</ul>
</li>
<li>并对网络层的服务进行增强<ul>
<li>数据丢失、顺序混乱、 加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有些服务是可以加强的：不可靠 -&gt; 可靠；安全<br>但有些服务是不可以被加强的：带宽，延迟</p>
<h3 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h3><p>可靠的、保序的传输： TCP(字节流的服务)</p>
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
<p>不可靠、不保序的传输：UDP(数据包的服务)</p>
<ul>
<li>多路复用、解复用 </li>
<li>没有为尽力而为的IP服务添加更多的其它额外服务 </li>
</ul>
<p><strong>都不提供的服务： 延时保证    带宽保证</strong></p>
<h2 id="3-2-多路复用与解复用"><a href="#3-2-多路复用与解复用" class="headerlink" title="3.2 多路复用与解复用"></a>3.2 多路复用与解复用</h2><p>多路复用/解复用（一个TCP/UDP实体上有很多应用进程借助其发送）</p>
<p>在发送方主机多路复用<br>从多个套接字接收来自多个进程的报文，<strong>根据套接字对应的IP地址和端口号</strong>等信息对报文段用头部加以封装 (该头部信息用于以后的<strong>解复用</strong>)</p>
<p>在接收方主机多路解复用<br>根据报文段的头部信息中的<strong>IP地址和端口号将接收到的报文段发给正确的套接字</strong>(和对应的应用进程)</p>
<p>多路解复用工作原理</p>
<ul>
<li>解复用作用：TCP或者UDP实体采 用哪些信息，将报文段的数据部分 交给正确的socket，从而交给正确 的进程</li>
<li>主机收到IP数据报 <ul>
<li>每个数据报有源IP地址和目标地 址 </li>
<li>每个数据报承载一个传输层报 文段 </li>
<li>每个报文段有一个源端口号和 目标端口号 (特定应用有著名的端口号)</li>
</ul>
</li>
<li>主机联合使用IP地址和端口号将报文段发送给合适的套接字</li>
</ul>
<p>无连接(UDP)多路解复用</p>
<p>当创建UDP段采用端口号，可以指定： • 目标IP地址 • 目标端口号<br>当主机接收到UDP段时： • 检查UDP段中的目标端 口号 • 将UDP段交给具备那个端口号的套接字<br><strong><u>目标IP地址，目标端口号一样发送给同一个进程</u></strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725125946183.png" alt="image-20210725125946183"></p>
<p>面向连接(TCP)的多路复用</p>
<p>TCP套接字:四元组本 地标识：  源IP地址  源端口号  目的IP地址  目的端口号<br>解复用：接收主机用 这四个值来将数据报 定位到合适的套接字</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725125934798.png" alt="image-20210725125934798"></p>
<p>socket 和message</p>
<h2 id="3-3-无连接传输：UDP"><a href="#3-3-无连接传输：UDP" class="headerlink" title="3.3 无连接传输：UDP"></a>3.3 无连接传输：UDP</h2><p>UDP: User Datagram Protocol  用户数据包协议<br>在IP（主机到主机）所提供的基础上增加了一个多路复用/解复用（进程到进程）的服务</p>
<ul>
<li><p>“尽力而为”的服务，报文 段可能 </p>
<ul>
<li>丢失 </li>
<li>送到应用进程的报文段乱序（延迟不一样）</li>
</ul>
</li>
<li><p>无连接：</p>
<ul>
<li>UDP发送端和接收端之间没有握手 </li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li><p>UDP 被用于: </p>
<ul>
<li>（实时）流媒体（丢失不敏感， 速率敏感、应用可控制 传输速率）</li>
<li>DNS</li>
<li>SNMP</li>
<li>事务性的应用(一次性往返搞定)</li>
</ul>
</li>
<li><p>在UDP上可行可靠传输: </p>
<ul>
<li><strong>在应用层增加可靠性</strong> </li>
<li><strong>应用特定的差错恢复</strong></li>
</ul>
</li>
</ul>
<h3 id="UDP：用户数据报协议"><a href="#UDP：用户数据报协议" class="headerlink" title="UDP：用户数据报协议"></a>UDP：用户数据报协议</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725134800713.png" alt="image-20210725134800713"></p>
<h3 id="为什么要有UDP"><a href="#为什么要有UDP" class="headerlink" title="为什么要有UDP?"></a>为什么要有UDP?</h3><ol>
<li><p>不建立连接 (会增加延时) </p>
</li>
<li><p>简单：在发送端和接收端没有连接状态 </p>
</li>
<li><p><strong>报文段的头部很小(开销小)</strong> </p>
</li>
<li><p><strong>无拥塞控制和流量控制</strong>：UDP可以尽可能快的发送报文段</p>
</li>
<li><p><strong>应用-&gt;传输的速率 = 主机-&gt;网络的速率 (忽略头部时)</strong></p>
</li>
</ol>
<p>UDP校验和<br>目标： 检测在被传输报文段中的差错 (如比特反转)</p>
<p>发送方：<br> 将报文段的内容视为16 比特的整数<br> 校验和：报文段的加法和（1的补运算）<br> 发送方将校验和放在 UDP的校验和字段</p>
<p>接收方：<br> 计算接收到的报文段的校验和<br> 检查计算出的校验和与校验和字段的内容是否相等：<br>     不相等–—检测到差错<br>     <strong>相等–—没有检测到差错 ，但也许还是有差错 (残存错误，为检测出来)</strong></p>
<h3 id="Internet校验和的例子"><a href="#Internet校验和的例子" class="headerlink" title="Internet校验和的例子"></a>Internet校验和的例子</h3><p>注意：当数字相加时，在最高位的进位要回卷（加到最低位上），再加到结果上</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725135335276.png" alt="image-20210725135335276"></p>
<p> <strong>目标端：校验范围+校验和=1111111111111111 通过校验</strong><br>     否则没有通过校验<br> 注：求和时，必须将进位回卷到结果上</p>
<h2 id="3-4-可靠数据传输的原理"><a href="#3-4-可靠数据传输的原理" class="headerlink" title="3.4 可靠数据传输的原理"></a>3.4 可靠数据传输的原理</h2><p>可靠数据传输（rdt）的原理            rdt(Reliable Data Transfer)</p>
<p> rdt在应用层、传输层和数据链路层都很重要<br> 是网络Top 10问题之一</p>
<p> 信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725151016012.png" alt="image-20210725151016012"></p>
<p> 渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方<br> 只考虑单向数据传输<br>     但控制信息是双向流动的！<br> <strong>双向的数据传输问题实际上是2个单向数据传输问题的综合</strong><br> 使用<strong>有限状态机 (FSM)</strong> 来描述发送方和接收方</p>
<h3 id="Rdt1-0：-在可靠信道上的可靠数据传输"><a href="#Rdt1-0：-在可靠信道上的可靠数据传输" class="headerlink" title="Rdt1.0： 在可靠信道上的可靠数据传输"></a>Rdt1.0： 在可靠信道上的可靠数据传输</h3><p><strong>下层的信道是完全可靠的</strong> </p>
<ul>
<li>没有比特出错 </li>
<li>没有分组丢失 </li>
</ul>
<p>发送方和接收方的FSM </p>
<ul>
<li>发送方将数据发送到下层信道 </li>
<li>接收方从下层信道接收数据</li>
</ul>
<p>发送方：接收—封装—打走       接收方：解封装—交付          什么都不用干      </p>
<h3 id="Rdt2-0：具有比特差错的信道"><a href="#Rdt2-0：具有比特差错的信道" class="headerlink" title="Rdt2.0：具有比特差错的信道"></a>Rdt2.0：具有比特差错的信道</h3><p>下层信道可能会出错：将分组中的比特翻转<br>     用校验和来检测比特差错 </p>
<p> 问题：怎样从差错中恢复：<br>     确认(ACK)：接收方显式地告诉发送方分组已被正确接收<br>     否定确认( NAK): 接收方显式地告诉发送方分组发生了差错<br>        • 发送方收到NAK后，发送方重传分组 </p>
<p> rdt2.0中的新机制：采用差错控制编码进行差错检测<br>     发送方差错控制编码、缓存<br>     接收方使用编码检错<br>     接收方的反馈：控制报文（ACK，NAK）：接收方-&gt;发送方<br>     发送方收到反馈相应的动作</p>
<h4 id="Rdt2-0：FSM描述"><a href="#Rdt2-0：FSM描述" class="headerlink" title="Rdt2.0：FSM描述"></a>Rdt2.0：FSM描述</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725152850739.png" alt="image-20210725152850739"></p>
<p>发送方接收nak (接收方检测出错) ，将之前封装的package重传，直到收到ack才开始下一轮的发送</p>
<h3 id="rdt2-0的致命缺陷！-gt-rdt2-1"><a href="#rdt2-0的致命缺陷！-gt-rdt2-1" class="headerlink" title="rdt2.0的致命缺陷！-&gt; rdt2.1"></a>rdt2.0的致命缺陷！-&gt; rdt2.1</h3><p>如果ACK/NAK出错？<br> 发送方不知道接收方发生了什么事情！<br> <strong>发送方如何做？</strong><br>     <strong>重传？可能重复</strong><br>     <strong>不重传？可能死锁(或出 错)</strong><br> <strong>需要引入新的机制</strong><br>     <strong>序号</strong></p>
<p>处理重复：<br>     发送方在每个分组中加 入序号<br>     如果ACK/NAK出错，发送方重传当前分组<br>     <strong><u>接收方丢弃（不发给上层）重复分组</u></strong><br>    <strong>接收方通过序号判断，是否重复接收同样的包，在进行下一次流程/发送ack</strong></p>
<p><strong>停等协议: 发送方发送一个分组， 然后等待接收方的应答</strong> </p>
<p>发送方： </p>
<ol>
<li>在分组中加入序列号<br> 两个序列号（0，1）就 足够了 <pre><code> 一次只发送一个未经确认 的分组 
</code></pre></li>
<li>必须检测ACK/NAK是否 出错（需要EDC ）<br>状态数变成了两倍<br>必须记住当前分组的序列号为0还是1</li>
</ol>
<p>接收方： </p>
<ol>
<li>必须检测接收到的分组是否是重复的 <pre><code> 状态会指示希望接收到的 分组的序号为0还是1 
</code></pre></li>
</ol>
<p>注意：接收方并不知道 发送方是否正确收到了 其ACK/NAK</p>
<p><strong>rdt2.1的运行</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725154944808.png" alt="image-20210725154944808"></p>
<p>接收方不知道它最后发送的ACK/NAK是否被正确地收到<br> 发送方不对收到的ack/nak给确认，<strong><u>没有所谓的确认的确认</u></strong>；<br> 接收方发送ack，如果后面接收方收到的是：<br>     <strong>老分组p0？则ack 错误</strong><br>     <strong>下一个分组？P1，ack正确</strong></p>
<h3 id="rdt2-2：无NAK的协议"><a href="#rdt2-2：无NAK的协议" class="headerlink" title="rdt2.2：无NAK的协议"></a>rdt2.2：无NAK的协议</h3><ul>
<li>功能同rdt2.1，但只使用ACK(ack 要编号） </li>
<li>接收方对最后正确接收的分组发ACK，以替代NAK <ul>
<li>接收方必须显式地包含被正确接收分组的序号 </li>
</ul>
</li>
<li><strong>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</strong> </li>
<li>为后面的一次发送多个数据单位做一个准备 <ul>
<li>一次能够发送多个 </li>
<li>每一个的应答都有：ACK，NACK；麻烦 </li>
<li>使用对前一个数据单位的ACK，代替本数据单位的nak </li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<p>NAK free </p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725155525434.png" alt="image-20210725155525434"></p>
<p><strong>rdt2.2的运行</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725155546252.png" alt="image-20210725155546252"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725155624953.png" alt="image-20210725155624953"></p>
<p>1、No error        2、packet error        3、ack error</p>
<h3 id="rdt3-0：具有比特差错和分组丢失的信道"><a href="#rdt3-0：具有比特差错和分组丢失的信道" class="headerlink" title="rdt3.0：具有比特差错和分组丢失的信道"></a>rdt3.0：具有比特差错和分组丢失的信道</h3><p><strong>新的假设：下层信道可 能会丢失分组（数据或ACK）</strong><br> 会死锁<br> 机制还不够处理这种 状况：<br>    • 检验和<br>    • 序列号<br>    • ACK<br>    • 重传</p>
<ul>
<li>方法：发送方等待ACK一段合理的时间 <pre><code>发送端**超时重传**：如果到时没有 收到ACK-&gt;重传 
</code></pre></li>
<li>问题：如果分组（或ACK ）只 是被延迟了： <pre><code>重传将会导致数据重复，但利用序列号已经可以处理这 个问题 
接收方必须指明被正确接收的序列号 
</code></pre></li>
<li>需要一个倒计数定时器</li>
</ul>
<p>链路层的timeout时间确定的  （比较集中）<br>传输层timeout时间是适应式的 （不太集中）</p>
<h4 id="rdt3-0的运行"><a href="#rdt3-0的运行" class="headerlink" title="rdt3.0的运行"></a>rdt3.0的运行</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725161318287.png" alt="image-20210725161318287"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725161335326.png" alt="image-20210725161335326"></p>
<p>1、no loss    2、packet loss    3、ACK loss    <strong>4、premature timeout/ delayed ACK</strong></p>
<p> <strong><u>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的；</u></strong><br> 设置一个合理的超时时间也是比较重要的；</p>
<h4 id="rdt3-0的性能"><a href="#rdt3-0的性能" class="headerlink" title="rdt3.0的性能"></a>rdt3.0的性能</h4><p><strong>rdt3.0可以工作，但链路容量比较大的情况下，性能很差</strong> </p>
<ul>
<li>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725171743570.png" alt="image-20210725171743570"></p>
<ul>
<li>U sender：利用率 – 忙于发送的时间比例 </li>
<li>每30ms发送1KB的分组 -&gt; 270kbps=33.75kB/s 的吞吐量（在1 Gbps 链路上） </li>
<li>瓶颈在于：网络协议限制了物理资源的利用！</li>
</ul>
<h3 id="rdt3-0：停-等操作-stop-wait"><a href="#rdt3-0：停-等操作-stop-wait" class="headerlink" title="rdt3.0：停-等操作  stop-wait"></a>rdt3.0：停-等操作  stop-wait</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725171641105.png" alt="image-20210725171641105"></p>
<p><strong>一次收发一个</strong></p>
<h3 id="流水线：提高链路利用率"><a href="#流水线：提高链路利用率" class="headerlink" title="流水线：提高链路利用率"></a>流水线：提高链路利用率</h3><p>pipeline</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725175741034.png" alt="image-20210725175741034"></p>
<p> 增加n,能提高链路利用率<br> 但当达到某个n,其u=100%时,无法再通过增加n，提高利用率<br> 瓶颈转移了-&gt;链路带宽</p>
<h4 id="流水线协议-管道化协议"><a href="#流水线协议-管道化协议" class="headerlink" title="流水线协议/管道化协议"></a>流水线协议/管道化协议</h4><p>流水线：允许发送方在未得到对方确认的情况下一次发送多个 分组<br> 必须增加序号的范围:用多个bit表示分组的序号<br> 在发送方/接收方要有缓冲区<br>• 发送方缓冲：未得到确认，可能需要重传；<br>• 接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可 能乱序，排序交付（可靠）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>slide window</th>
<th>sw(sending window)</th>
<th>rw(receiving window)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>=1</td>
<td>=1</td>
<td>stop-wait</td>
</tr>
<tr>
<td>流水线协议</td>
<td>&gt;1</td>
<td>=1</td>
<td>GBN</td>
</tr>
<tr>
<td>流水线协议</td>
<td>&gt;1</td>
<td>&gt;1</td>
<td>SR</td>
</tr>
</tbody>
</table>
</div>
<p>两种通用的流水线协议：回退N步(GBN)和选择重传(SR)</p>
<h4 id="发送缓冲区"><a href="#发送缓冲区" class="headerlink" title="发送缓冲区"></a>发送缓冲区</h4><ul>
<li><strong>形式：内存中的一个区域，<u>落入缓冲区的分组可以发送</u></strong> </li>
<li><strong>功能：用于存放已发送，但是没有得到确认的分组</strong> </li>
<li><strong>必要性：需要重发时可用</strong> </li>
</ul>
<p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组 </p>
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100% </li>
</ul>
<p>发送缓冲区中的分组 </p>
<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去； </li>
<li><strong>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</strong></li>
</ul>
<h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>采用相对移动方式表示，分组不动<br>可缓冲范围移动，代表一段可以发送的权力</p>
<p><strong>发送窗口：发送缓冲区内容的一个范围</strong> </p>
<ul>
<li>那些已发送但是未经确认分组的序号构成的空间 </li>
</ul>
<p>发送窗口的最大值&lt;=发送缓冲区的值<br>一开始：没有发送任何一个分组 </p>
<ul>
<li>后沿=前沿 </li>
<li>之间为发送窗口的尺寸=0 </li>
</ul>
<p>每发送一个分组，前沿前移一个单位</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725180820132.png" alt="image-20210725180820132"></p>
<p>发送窗口前沿移动的极限：不能够超过<strong>发送缓冲区的大小</strong></p>
<p>发送窗口后沿移动<br>    条件：收到老分组的确认<br>    结果：发送缓冲区罩住新的分组，来了分组可以发送<br>    移动的极限：不能够超过前沿</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725181322552.png" alt="image-20210725181322552"></p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>slide window</th>
<th>sw (sending window)</th>
<th>rw (receiving window)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>=1</td>
<td>=1</td>
<td>stop-wait</td>
</tr>
<tr>
<td>流水线协议</td>
<td>&gt;1</td>
<td>=1</td>
<td>GBN</td>
</tr>
<tr>
<td>流水线协议</td>
<td>&gt;1</td>
<td>&gt;1</td>
<td>SR</td>
</tr>
</tbody>
</table>
</div>
<p><strong>两种通用的流水线协议：回退N步(GBN)和选择重传(SR)</strong></p>
<p>接收窗口 (receiving window)=接收缓冲区 </p>
<ul>
<li>接收窗口用于控制哪些分组可以接收；<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃；</li>
</ul>
</li>
<li><strong>接收窗口尺寸Wr=1，则只能顺序接收；</strong></li>
<li><strong>接收窗口尺寸Wr&gt;1 ，则可以乱序接收</strong><ul>
<li>但提交给上层的分组，要按序</li>
</ul>
</li>
</ul>
<p>例子：Wr＝1，在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢 弃。</p>
<p>接收窗口的滑动和发送确认 </p>
<ul>
<li>滑动： <ul>
<li>低序号的分组到来，接收窗口移动； </li>
<li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动 </li>
</ul>
</li>
<li>发送确认： <ul>
<li><strong>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认）</strong> </li>
<li><strong>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认）</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725184310106.png" alt="image-20210725184310106"></p>
<h4 id="正常情况下的2个窗口互动"><a href="#正常情况下的2个窗口互动" class="headerlink" title="正常情况下的2个窗口互动"></a>正常情况下的2个窗口互动</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725184748257.png" alt="image-20210725184748257"></p>
<h4 id="异常情况下GBN的2窗口互动"><a href="#异常情况下GBN的2窗口互动" class="headerlink" title="异常情况下GBN的2窗口互动"></a>异常情况下GBN的2窗口互动</h4><p>发送窗口</p>
<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li><p><strong>超时重发机制让发送端将发送窗口中的所有分组发送出去</strong></p>
</li>
<li><p>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围团(此时如果发送缓冲区有新的分组可以发送)</p>
</li>
</ul>
<p>接收窗口</p>
<ul>
<li>收到乱序分组，没有落入到接收窗口范界内，抛弃</li>
<li>(重复）发送老分组的确认，<strong>累计确认</strong></li>
</ul>
<h4 id="异常情况下SR的2窗口互动"><a href="#异常情况下SR的2窗口互动" class="headerlink" title="异常情况下SR的2窗口互动"></a>异常情况下SR的2窗口互动</h4><p>发送窗口</p>
<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li><strong>超时重发机制让发送端将超对的分组重新发送出去</strong></li>
<li>来了乱序分组的确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围（此时如果发送缓冲率有新的分组可以发送)</li>
</ul>
<p>接收窗口</p>
<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，<strong>单独确认</strong></li>
</ul>
<h4 id="GBN协议和SR协议的异同"><a href="#GBN协议和SR协议的异同" class="headerlink" title="GBN协议和SR协议的异同"></a>GBN协议和SR协议的异同</h4><p>相同之处      发送窗口&gt;1      一次能够可发送多个 未经确认的分组</p>
<p>不同之处 </p>
<p>GBN :接收窗口尺寸=1 </p>
<ul>
<li><strong>接收端：只能顺序接收</strong> </li>
<li><strong>发送端：从表现来看，一旦一个 分组没有发成功，如：0,1,2,3,4 ; 假如1未成功，234都发送出去 了，要返回1再发送；GB1(go back 1)</strong> </li>
</ul>
<p>SR: 接收窗口尺寸&gt;1 </p>
<ul>
<li><strong>接收端：可以乱序接收</strong> </li>
<li><strong>发送端：发送0,1,2,3,4，一旦1 未成功，2,3,4,已发送，无需重发，选择性发送1</strong></li>
</ul>
<p><strong>Go-back-N:</strong><br> 发送端最多在流水线中有N个未确认的分组<br> <strong>接收端只是发送<u>累计型确认</u>(cumulative ack)</strong><br>     接收端如果发现gap，不确认新到来的分组 </p>
<p>发送端拥有对最老的 未确认分组的定时器<br>   只需设置一个定时器<br>   <strong>当定时器到时时，重传所有未确认分组</strong></p>
<p><strong>Selective Repeat:</strong><br> 发送端最多在流水线中有N个未确认的分组<br> 接收方对每个到来的分组单独确认individual ack （非累计确认）</p>
<p>发送方为每个未确认的分组保持一个定时器<br>    当超时定时器到时，只是重发到时的未确认分组</p>
<h4 id="运行中的GBN"><a href="#运行中的GBN" class="headerlink" title="运行中的GBN"></a>运行中的GBN</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725191547108.png" alt="image-20210725191547108"></p>
<h4 id="选择重传SR的运行"><a href="#选择重传SR的运行" class="headerlink" title="选择重传SR的运行"></a>选择重传SR的运行</h4><p> 发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</p>
<p>发送方</p>
<blockquote>
<p>从上层接收数据：<br> 如果下一个可用于该分组的序 号可在发送窗口中，则发送<br>timeout(n):<br> 重新发送分组n，重新设定定时器<br>ACK(n) in [sendbase,sendbase+N]:<br> 将分组n标记为已接收<br> 如n为最小未确认的分组序号， 将base移到下一个未确认序号</p>
</blockquote>
<p>接收方</p>
<blockquote>
<p>分组n [rcvbase, rcvbase+N-1]<br> 发送ACK(n)<br> 乱序：缓存<br> 有序：该分组及以前缓存的 序号连续的分组交付给上层 ，然后将窗口移到下一个仍 未被接收的分组<br>分组n [rcvbase-N, rcvbase-1]<br> ACK(n) 其它：<br> 忽略该分组</p>
</blockquote>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210725191937619.png" alt="image-20210725191937619"></p>
<h4 id="对比GBN和SR"><a href="#对比GBN和SR" class="headerlink" title="对比GBN和SR"></a>对比GBN和SR</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>简单，所需资源少（接收方一个 缓存单元）</td>
<td>出错时，重传一个代价小</td>
</tr>
<tr>
<td>缺点</td>
<td>一旦出错，回退N步代价大</td>
<td>复杂，所需要资源多（接收方多个 缓存单元）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>适用范围</strong> </p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必 要用复杂的SR，为罕见的事件做日常的准备和复杂处理 </li>
<li>链路容量大<strong>（延迟大、带宽大）</strong>：比较适合SR而不 是GBN，一点出错代价太大</li>
</ul>
<p><strong>窗口的最大尺寸</strong></p>
<p> GBN: 2^n -1<br> SR:2^(n-1) 例<br>如：n=2; 序列号：0, 1, 2, 3<br>     GBN =3<br>     SR=2<br>SR的例子：  接收方看不到二者的区别！  将重复数据误认为新数据 (a) </p>
<p>Q: 序号大小与窗口大小 之间的关系？</p>
<h2 id="3-5-面向连接的传输：-TCP"><a href="#3-5-面向连接的传输：-TCP" class="headerlink" title="3.5 面向连接的传输： TCP"></a>3.5 面向连接的传输： TCP</h2><p>点对点：一个发送方，一个接收方</p>
<p>可靠的、按顺序的字节流：没有报文边界</p>
<p>管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小</p>
<p>发送和接收缓存</p>
<p>全双工数据：</p>
<ul>
<li>在同一连接中数据流双向 流动</li>
<li>MSS：最大报文段大小     MSS的大小  + TCP头部 + IP头部 = 一个报文段</li>
</ul>
<p>面向连接：在数据交换之前，通过握 手（交换控制报文） 初始 化发送方、接收方的状态 变量 </p>
<p>有流量控制：发送方不会淹没接收方</p>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726073703179.png" alt="image-20210726073703179"></p>
<p><strong>序号：报文段首字节的在字节流的编号</strong> </p>
<p><strong>确认号：1、期望从另一方收到的下一个字节的序号 2、累积确认</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726074323701.png" alt="image-20210726074323701"></p>
<h4 id="TCP序号和确认号"><a href="#TCP序号和确认号" class="headerlink" title="TCP序号和确认号"></a>TCP序号和确认号</h4><p><img src="C:\Users\20662\AppData\Roaming\Typora\typora-user-images\image-20210726075010148.png" alt="image-20210726075010148"></p>
<h4 id="TCP-往返延时（RTT）和超时"><a href="#TCP-往返延时（RTT）和超时" class="headerlink" title="TCP  往返延时（RTT）和超时"></a>TCP  往返延时（RTT）和超时</h4><p>怎样设置TCP 超时？<br>比RTT要长 ，但RTT是变化的<br>太短：太早超时 ，不必要的重传<br>太长：对报文段丢失反应太慢，消极</p>
<p>怎样估计RTT？<br>SampleRTT：测量从报文段发出到 收到确认的时间  如果有重传，忽略此次测量<br>SampleRTT会变化，因此估计的 RTT应该比较平滑  对几个最近的测量值求平均，而 不是仅用当前的SampleRTT</p>
<p>EstimatedRTT = (1- a)*EstimatedRTT + a<em>SampleRTT<br> <strong><u>指数加权移动平均</u></strong><br> <em>*过去样本的影响呈指数衰减</em></em><br> 推荐值：a = 0.125</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726075613747.png" alt="image-20210726075613747"></p>
<h4 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726075813845.png" alt="image-20210726075813845"></p>
<h3 id="TCP：可靠数据传输"><a href="#TCP：可靠数据传输" class="headerlink" title="TCP：可靠数据传输"></a>TCP：可靠数据传输</h3><p>TCP在IP不可靠服务的基础上 建立了rdt<br> 管道化的报文段 • GBN or SR </p>
<p> <strong>累积确认（像GBN）</strong><br> <strong>单个重传定时器（像GBN）</strong><br> <strong>是否可以接受乱序的，没有规范</strong></p>
<p>通过以下事件<strong>触发重传</strong><br> <strong>超时（只重发那个最早的未确认段：SR）</strong><br> <strong>重复的确认</strong><br>        • 例子：收到了ACK50,之后又收到3 个ACK50</p>
<p>首先考虑简化的TCP发送方：  忽略重复的确认  忽略流量控制和拥塞控 制</p>
<h4 id="TCP发送方事件："><a href="#TCP发送方事件：" class="headerlink" title="TCP发送方事件："></a>TCP发送方事件：</h4><p>从应用层接收数据：<br> 用nextseq创建报文段<br> 序号nextseq为报文段首字节的字节流编号<br> 如果还没有运行，启动定时器</p>
<p>超时：<br> <strong>重传后沿最老的报文段</strong><br> <strong>重新启动定时器</strong></p>
<p>收到确认：<br> 如果是对尚未确认的报文段确认<br>     更新已被确认的报文序号<br>     如果当前还有未被确认的报文段，重新启动定时器 (发完，就关掉定时器)</p>
<p>TCP重传</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726081314233.png" alt="image-20210726081314233"></p>
<p>ACK丢失                过早超时                    对顺序收到的最高字节确认</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726082045415.png" alt="image-20210726082045415"></p>
<p><strong>产生TCP ACK的建议</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接收方的事件</th>
<th>TCP接收方动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>所期望序号的报文段按序到达。 所有在期望序号之前的数据都已经被确认</td>
<td>延迟的ACK（提高效率，少发一个ACK）。对另一个按序报文段的到达最多等待500ms。如果下一个报文段<strong>在这个时间间隔内没有到达</strong>，则发送一个ACK。</td>
</tr>
<tr>
<td>有期望序号的报文段到达。 另一个按序报文段等待发送ACK</td>
<td><strong>立即发送单个累积ACK，以确认两个按序报文段。</strong></td>
</tr>
<tr>
<td>比期望序号大的报文段乱序到达。 检测出数据流中的间隔</td>
<td>立即发送重复的ACK，<strong>指明下一个期待字节的序号</strong></td>
</tr>
<tr>
<td>能部分或完全填充接收数据间隔 的报文段到达</td>
<td>若该报文段起始于间隔（gap）的低端， 则立即发送ACK（给确认。反映下一段的需求）。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>超时周期往往太长：<br>    在重传丢失报文段之前的延时太长</p>
<p>通过重复的ACK来检测 报文段丢失<br>     发送方通常连续发送大量 报文段<br>     如果报文段丢失，通常会引起多个重复的ACK</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726083307463.png" alt="image-20210726083307463"></p>
<p>如果发送方收到同一数据 的3个冗余ACK，重传最 小序号的段：<br> <strong>快速重传：在定时器过时之前重发报文段</strong> </p>
<p> 它假设跟在被确认的数据 后面的数据丢失了 </p>
<p>• 第一个ACK是正常的； </p>
<p>• 收到第二个该段的ACK，表 示接收方收到一个该段后的乱序段； </p>
<p>• 收到第3，4个该段的ack，表 示接收方收到该段之后的2个 ，3个乱序段，可能性非常大段丢失了</p>
<p><strong>三重ACK接收后的快速重传</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726083418896.png" alt="image-20210726083418896"></p>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>流量控制<br>接收方控制发送方，不让发送方发送的太多、太快以至于让 接收方的缓冲区溢出</p>
<p>接收方在其向发送方的TCP段 头部的rwnd字段“通告”其空闲buffer大小 </p>
<ul>
<li>RcvBuffer大小通过socket选项 设置 (典型默认大小为4096 字 节) </li>
<li>很多操作系统自动调整 RcvBuffer</li>
</ul>
<p>发送方限制未确认(“inflight”)字节的个数≤接收 方发送过来的 rwnd 值 </p>
<p>保证接收方不会被淹没</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726115906902.png" alt="image-20210726115906902"></p>
<p>RcvWindow = 缓冲区空间 - 已经接收到未读取的空间</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>在正式交换数据之前，发送方和接收方握手建立通 信关系:<br> <strong>同意建立连接（每一方都知道对方愿意建立连接）</strong><br> <strong>同意连接参数</strong></p>
<h4 id="同意建立连接"><a href="#同意建立连接" class="headerlink" title="同意建立连接"></a>同意建立连接</h4><p>在网络中，2次握手建 立连接总是可行吗？<br> 变化的延迟（连接请求的段没有丢，但可能超时）<br> 由于丢失造成的重传 (e.g. req_conn(x))<br> 报文乱序<br> 相互看不到对方</p>
<p>2次握手的失败场景：</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726121120744.png" alt="image-20210726121120744"></p>
<p>1、可能发送半连接（只在服务器维护了连接）<br>2、老的数据被当成新的数据接收了    <strong><u>seq  x 和 x + 1</u></strong></p>
<p>TCP 3次握手</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726121321781.png" alt="image-20210726121321781"></p>
<p><strong>解决方案：变化的初始序号+双方确认对方的序号 (3次握手)</strong></p>
<p>第一次：SYNbit + seq    第二次：SYNbit + ACKbit + seq + ACKnum    第三次：ACKbit + ACKnum</p>
<h4 id="3次握手解决：半连接和接收老数据问题"><a href="#3次握手解决：半连接和接收老数据问题" class="headerlink" title="3次握手解决：半连接和接收老数据问题"></a><u>3次握手解决：半连接和接收老数据问题</u></h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726121605926.png" alt="image-20210726121605926"></p>
<p><strong>二次握手：可能发送半连接（只在服务器维护了连接）</strong><br><strong>三次握手：客户端在第三次握手拒绝连接请求  服务器二次握手后的连接请求</strong></p>
<p><strong>二次握手：老的数据被当成新的数据接收了</strong><br><strong>三次握手：未建立连接（无半连接），故将发来的数据丢掉</strong></p>
<p>扔掉：连接不存在， 没建立起来；连接的 序号不在当前连接的 范围之内</p>
<p><strong>若一个数据滞留时间足够长导致</strong><br><strong>在TCP第二次连接（两个三次握手后）到来，这个数据包大概率也会被丢弃，因为seq不一样，而seq又与时间有关</strong></p>
<h4 id="TCP-关闭连接"><a href="#TCP-关闭连接" class="headerlink" title="TCP: 关闭连接"></a>TCP: 关闭连接</h4><ul>
<li><strong>客户端，服务器分别关闭它自己这一侧的连接</strong> <ul>
<li><strong>发送FIN bit = 1的TCP段</strong></li>
</ul>
</li>
<li><strong>一旦接收到FIN，用ACK回应</strong><ul>
<li><strong>接到FIN段，ACK可以和它自己发出的FIN段一起发 送</strong></li>
</ul>
</li>
<li><strong>可以处理同时的FIN交换</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726124018451.png" alt="image-20210726124018451"></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h2 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h2><p>拥塞:<br> 非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力”<br> 与流量控制不同<br> 拥塞的表现:<br>     <strong><u>分组丢失 (路由器缓冲区溢出)</u></strong><br>     <strong><u>分组经历比较长的延迟(在路由器的队列中排队)</u></strong><br> 网络中前10位的问题!</p>
<h3 id="拥塞的原因-代价-场景1"><a href="#拥塞的原因-代价-场景1" class="headerlink" title="拥塞的原因/代价: 场景1"></a>拥塞的原因/代价: 场景1</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726125936998.png" alt="image-20210726125936998"></p>
<h3 id="拥塞的原因-代价-场景2"><a href="#拥塞的原因-代价-场景2" class="headerlink" title="拥塞的原因/代价: 场景2"></a>拥塞的原因/代价: 场景2</h3><p> 一个路由器，有限的缓冲<br> 分组丢失时，发送端重传<br>    应用层的输入=应用层输出:  λ(in) =  λ(out)<br>    传输层的输入包括重传:  λ(in‘) &gt;=  λ(in)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726130345272.png" alt="image-20210726130345272"></p>
<p>理想化: 发送端有完美的信息<br>发送端知道什么时候路由器的缓冲是可用的<br>     只在缓冲可用时发送<br>     不会丢失: λ(in‘’) =  λ(in)</p>
<p>理想化: 掌握丢失信息 分组可以丢失，在路由器由 于缓冲器满而被丢弃  如果知道分组丢失了，发 送方重传分组</p>
<p>现实情况: 重复  分组可能丢失，由于缓冲器 满而被丢弃  发送端最终超时，发送第2 个拷贝，2个分组都被传出</p>
<p>现实情况: 重复  分组可能丢失，由于缓冲器 满而被丢弃  发送端最终超时，发送第2 个拷贝，2个分组都传到</p>
<p>拥塞的“代价”:<br> 为了达到一个有效输出，网络需要做更多的工作（重传）<br> 没有必要的重传，链路中包括了多个分组的拷贝<br>     是那些没有丢失，经历的时间比较长（拥塞状态）但是 超时的分组<br>     降低了的“goodput”</p>
<p><u><strong>输出比输入少原因：1）重传的丢失分组；2） 没有必要重传的重复分组</strong></u></p>
<h3 id="拥塞的原因-代价-场景3"><a href="#拥塞的原因-代价-场景3" class="headerlink" title="拥塞的原因/代价: 场景3"></a>拥塞的原因/代价: 场景3</h3><p>1、4个发送端        2、多重路径        3、超时／重传</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726131141125.png" alt="image-20210726131141125"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726131409102.png" alt="image-20210726131409102"></p>
<p>又一个拥塞的代价:<br> 当分组丢失时，<strong>任何“关于这个分组的上游传输能力” 都被浪费了</strong></p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>2种常用的拥塞控制方法: </p>
<p>端到端拥塞控制:<br> 没有来自网络的显式反馈<br> <strong>端系统根据延迟和丢失事件推断是否有拥塞</strong><br> TCP采用的方法</p>
<p>网络辅助的拥塞控制:<br> <strong>路由器提供给端系统以反馈信息</strong><br>     单个bit置位，显示有拥塞 (SNA, DECbit, TCP/IP ECN, ATM)<br>     显式提供发送端可以采用的速率</p>
<h3 id="案例学习-ATM-ABR-拥塞控制"><a href="#案例学习-ATM-ABR-拥塞控制" class="headerlink" title="案例学习: ATM ABR 拥塞控制"></a>案例学习: ATM ABR 拥塞控制</h3><p>ABR: available bit rate:<br> “弹性服务”<br> <strong>如果发送端的路径“轻载 ”    发送方使用可用带宽</strong><br> <strong>如果发送方的路径拥塞了    发送方限制其发送的速度到一个 <u>最小保障速率</u> 上</strong></p>
<p><strong>RM (资源管理) 信元:</strong><br> 由发送端发送,在数据信元中间隔插入<br> RM信元中的比特被交换机设置 (“网络辅助”)    有无拥塞<br>         <strong>NI bit: no increase in rate (轻微拥塞)速率不要增加了</strong><br>         <strong>CI bit: congestion indication 拥塞指示</strong><br> 发送端发送的RM 信元被接收端返回, 接收端不做任何 改变</p>
<p>在RM信元中的2个字节 ER (explicit rate)字段    多大带宽<br>     <strong>拥塞的交换机可能会<u>降低信元中ER的值</u></strong><br>     <strong>发送端发送速度因此是  <u>最低的可支持速率(交换机)</u></strong> </p>
<p>数据信元中的EFCI bit: 被拥塞的交换机设置成1<br>     如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在 返回的RM信元中设置CI bit</p>
<p>总结：网络提供一些信息，包括一些标志位的置位以及字段 (为两主机间的通信提供多大的带宽)</p>
<h2 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h2><h3 id="TCP-拥塞控制：机制"><a href="#TCP-拥塞控制：机制" class="headerlink" title="TCP 拥塞控制：机制"></a>TCP 拥塞控制：机制</h3><p>端到端的拥塞控制机制<br> 路由器不向主机有关拥塞的反馈信息<br>    • 路由器的负担较轻<br>    • <strong>符合网络核心简单的 TCP/IP架构原则</strong> </p>
<p> <strong>端系统根据自身得到的信息</strong> ，判断是否发生拥塞，从而 采取动作</p>
<p>拥塞控制的几个问题<br> 如何检测拥塞<br>     轻微拥塞<br>     拥塞<br> 控制策略<br>     在拥塞发送时如何动 作，降低速率<br>        • 轻微拥塞，如何降低<br>        • 拥塞时，如何降低<br> 在拥塞缓解时如何动 作，增加速率</p>
<h3 id="TCP-拥塞控制：拥塞感知"><a href="#TCP-拥塞控制：拥塞感知" class="headerlink" title="TCP 拥塞控制：拥塞感知"></a>TCP 拥塞控制：拥塞感知</h3><p>发送端如何探测到拥塞?</p>
<ol>
<li><p>某个段超时了（丢失事件 ）：拥塞<br> 超时时间到，某个段的确认没有来<br> <strong>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</strong><br> <strong>原因2：<u>出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小</u></strong><br> 一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</p>
</li>
<li><p><strong>有关某个段的3次重复ACK：轻微拥塞</strong><br> 段的第1个ack，正常，确认绿段，期待红段<br> 段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达<br> 段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了， 红段都没到）<br> <strong>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</strong></p>
</li>
</ol>
<h3 id="TCP-拥塞控制：速率控制方法"><a href="#TCP-拥塞控制：速率控制方法" class="headerlink" title="TCP 拥塞控制：速率控制方法"></a>TCP 拥塞控制：速率控制方法</h3><p>如何控制发送端发送的速率<br> <strong><u>维持一个拥塞窗口的值：CongWin (主要手段)</u></strong><br> 发送端限制  <strong><u>已发送但是未确认</u></strong> 的数据量<strong><u>（的上限）</u></strong>: LastByteSent-LastByteAcked  &lt;= CongWin<br> 从而<strong>粗略地控制</strong>发送方的往网络中注入的速率</p>
<p><strong>RTT 往返延时</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726150610364.png" alt="image-20210726150610364"></p>
<p>如何控制发送端发送的速率<br> CongWin是动态的，是感知到的网络拥塞程度的函数<br>         <strong>超时或者3个重复ack，CongWin↓（下降）</strong><br>            • 超时时：<strong>CongWin降为1MSS</strong>，<strong>进入SS阶段</strong>然后再倍增到 CongWin(原) / 2（每个RTT），从而<strong>进入CA阶段</strong><br>            • 3个重复ack ：CongWin降为CongWin/2,CA阶段<br> 否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试↑ （上升）<br>            • <strong>SS阶段：加倍增加(每个RTT)</strong><br>            • <strong>CA阶段：线性增加(每个RTT)</strong></p>
<h3 id="TCP拥塞控制和流量控制的联合动作"><a href="#TCP拥塞控制和流量控制的联合动作" class="headerlink" title="TCP拥塞控制和流量控制的联合动作"></a>TCP拥塞控制和流量控制的联合动作</h3><p>联合控制的方法:<br> 发送端控制发送但是未确认的量同时也不能够超过接收 窗口，满足流量控制要求<br>     <strong><u>SendWin=min{CongWin, RecvWin}</u></strong><br>     同时满足 拥塞控制和流量控制要求</p>
<h3 id="拥塞控制策略"><a href="#拥塞控制策略" class="headerlink" title="拥塞控制策略"></a>拥塞控制策略</h3><p> 慢启动<br> AIMD：线性增、乘性减少<br> 超时事件后的保守策略</p>
<h4 id="TCP-慢启动"><a href="#TCP-慢启动" class="headerlink" title="TCP 慢启动"></a>TCP 慢启动</h4><p>连接刚建立, CongWin = 1 MSS </p>
<ul>
<li>如: MSS = 1460bytes &amp; RTT = 200 msec  初始速率 = 58.4kbps </li>
</ul>
<p>可用带宽可能&gt;&gt; MSS/RTT </p>
<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
<p>当连接开始时，指数性增加发送速率，直到发生丢失的事件 </p>
<ul>
<li>1、启动初值很低        2、但是速度很快</li>
</ul>
<p>当连接开始时，指数性增 加（每个RTT）发送速率 直到发生丢失事件<br> 每一个RTT， CongWin加倍<br> 每收到一个ACK时， CongWin加1（why）<br> 慢启动阶段：只要不超时或 3个重复ack，一个RTT， CongWin加倍</p>
<p>总结: 初始速率很慢，但是加速却是指数性的  指数增加，SS时间很短，长期来看可以忽略</p>
<h4 id="TCP-拥塞控制：AIMD"><a href="#TCP-拥塞控制：AIMD" class="headerlink" title="TCP 拥塞控制：AIMD"></a>TCP 拥塞控制：AIMD</h4><p>乘性减: 丢失事件后将CongWin降为1(ss阶段通常可忽略，故相当于直接减少到 CongWin/2 )，将CongWin/2作为阈值，进入慢启动阶段（倍增直到 CongWin/2）</p>
<p>加性增： <strong>当 CongWin &gt;阈值时</strong>，一个 RTT 如没有发生丢失事件，将 CongWin 加1MSS : 探 测</p>
<p>当收到3个重复的ACKs: </p>
<ul>
<li>CongWin 减半 </li>
<li>窗口（缓冲区大小）之后 线性增长</li>
</ul>
<p>当超时事件发生时: </p>
<ul>
<li>CongWin被设置成 1 MSS，进入SS阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值（上次发 生拥塞的窗口的一半）时 ，再线性增加</li>
</ul>
<h3 id="总结-TCP拥塞控制"><a href="#总结-TCP拥塞控制" class="headerlink" title="总结: TCP拥塞控制"></a>总结: TCP拥塞控制</h3><p>出现丢失，Threshold设置成 CongWin的1/2</p>
<ul>
<li><p>当CongWin＜Threshold, 发送端处于慢启动阶段（ slow-start）, 窗口指数性增长. </p>
</li>
<li><p>当CongWin &gt; Threshold, 发送端处于拥塞避免阶段 （congestion-avoidance）, 窗口线性增长. </p>
</li>
<li>当收到三个重复的ACKs (triple duplicate ACK), Threshold设置成 CongWin/2， CongWin=Threshold+3. </li>
<li>当超时事件发生时timeout, Threshold=CongWin/2 CongWin=1 MSS，进入SS阶段</li>
</ul>
<h4 id="TCP-发送端拥塞控制"><a href="#TCP-发送端拥塞控制" class="headerlink" title="TCP 发送端拥塞控制"></a>TCP 发送端拥塞控制</h4><p>状态转换</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210726153615143.png" alt="image-20210726153615143"></p>
<h3 id="TCP-吞吐量"><a href="#TCP-吞吐量" class="headerlink" title="TCP 吞吐量"></a>TCP 吞吐量</h3><p>TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来 描述?<br> 忽略慢启动阶段，假设发送端总有数据传输</p>
<p>W：发生丢失事件时的窗口尺寸（单位：字节）<br> <strong>平均窗口尺寸（#in-flight字节）：3/4W</strong><br> <strong>平均吞吐量：一个RTT时间吞吐3/4W， avg TCP thruput = 3/4 * (W/RTT) bytes/sec</strong></p>
<h3 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h3><p><strong>公平性目标</strong>: 如果 <strong>K个TCP会话</strong>分享一个链路带宽为R的 瓶颈，每一个会话的有效带宽为 <strong>R/K</strong></p>
<p>2个竞争的TCP会话:<br> 加性增加，斜率为1, 吞吐量增加<br> 乘性减，吞吐量比例减少</p>
<p><strong><u>往返延迟相同时，TCP会话竞争的最终，双方的 有效的带宽 将收敛到 链路带宽 的一半。</u></strong><br><u><strong>所以相互竞争时 应用建立的TCP会话越多，占有带宽一般越大。</strong></u></p>
<p>公平性和 UDP<br> 多媒体应用通常不是用 TCP<br> 应用发送的数据速率希望 不受拥塞控制的节制<br>使用UDP:  音视频应用泵出数据的速率是恒定的, 忽略数据的丢失  研究领域: TCP 友好性</p>
<p>公平性和并行TCP连接<br> 2个主机间可以打开多个并行的TCP连接<br> Web浏览器 </p>
<ul>
<li>例如: 带宽为R的链路支持了 9个连接; <ul>
<li>如果新的应用要求建1个TCP连接,获得带宽R/10 </li>
<li>如果新的应用要求建11个TCP连接,获得带宽R/2</li>
</ul>
</li>
</ul>
<h2 id="第三章-总结"><a href="#第三章-总结" class="headerlink" title="第三章 总结"></a>第三章 总结</h2><ul>
<li>传输层提供的服务 <ul>
<li>应用进程间的逻辑通信<ul>
<li>Vs 网络层提供的是主机到主机的通信服务 </li>
</ul>
</li>
<li>互联网上传输层协议：UDP TCP <ul>
<li>特性 </li>
</ul>
</li>
</ul>
</li>
<li>多路复用和解复用 <ul>
<li>端口：传输层的SAP </li>
<li>无连接的多路复用和解复用 </li>
<li>面向连接的多路复用和解复用 </li>
</ul>
</li>
<li>实例1：无连接传输层协议 UDP <ul>
<li>多路复用解复用</li>
<li>UDP报文格式</li>
<li>检错机制：校验和</li>
</ul>
</li>
<li><p>可靠数据传输原理</p>
<ul>
<li>问题描述</li>
<li>停止等待协议<ul>
<li>Rdt1.0 rdt2.0,2.1 ,2.2 Rdt 3.0 </li>
</ul>
</li>
<li>流水线协议 <ul>
<li>GBN</li>
<li>SR（Selective Repeat）</li>
</ul>
</li>
</ul>
</li>
<li><p>实例2：面向连接的 传输层协议-TCP </p>
<ul>
<li>概述：TCP特性 </li>
<li>报文段格式<ul>
<li>序号，超时机制及时间</li>
</ul>
</li>
<li>TCP可靠传输机制</li>
<li>重传，快速重传</li>
<li>流量控制</li>
<li>连接管理<ul>
<li>三次握手</li>
<li>对称连接释放</li>
</ul>
</li>
<li>拥塞控制原理<ul>
<li>网络辅助的拥塞控制</li>
<li>端到端的拥塞控制</li>
</ul>
</li>
<li>TCP的拥塞控制<ul>
<li>AIMD</li>
<li>慢启动</li>
<li>超时之后的保守策略</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第六章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：19:02:02" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络第六章"><a href="#计算机网络第六章" class="headerlink" title="计算机网络第六章"></a>计算机网络第六章</h1><p>第6章：链路层和局域网</p>
<p>导引:<br>网络层解决了一个网络如何到达另外一个 网络的路由问题<br>在一个网络内部如何由一个节点（主机或 者路由器）到达另外一个相邻节点<br>    链路层的点到点传输层功能</p>
<p>目标:</p>
<ul>
<li><p>理解数据链路层服务的原理:</p>
<ul>
<li>检错和纠错</li>
<li>共享广播信道:多点接入（多路访问）</li>
<li>链路层寻址</li>
<li>LAN:以太网、WLAN、VLANs</li>
<li>可靠数据传输，流控制:解决!</li>
</ul>
</li>
<li><p>实例和各种链路层技术的实现</p>
</li>
</ul>
<p>网络节点的连接方式</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002174622379.png" alt="image-20211002174622379"></p>
<h2 id="数据链路层和局域网"><a href="#数据链路层和局域网" class="headerlink" title="数据链路层和局域网"></a>数据链路层和局域网</h2><p>WAN—— 广域网，LAN —— 局域网</p>
<ul>
<li><p><strong>==WAN:网络形式采用点到点链路==</strong><br> 带宽大、距离远（延迟大） </p>
<pre><code>&gt;带宽延迟积大 
</code></pre><p> 如果采用多点连接方式<br>   • 竞争方式：一旦冲突代价 大<br>   • 令牌等协调方式：在其中 协调节点的发送代价大</p>
</li>
<li><p><strong>==点到点链路的链路层服务 实现非常简单，封装和解 封装==</strong></p>
</li>
</ul>
<ul>
<li><p><strong>LAN一般采用多点连接方式</strong><br> 连接节点非常方便  接到共享型介质上（或网络 交换机），就可以连接所有其他节点</p>
</li>
<li><p><strong>多点连接方式网络的链路层 功能实现相当复杂</strong><br> 多点接入：协调各节点对共 享性介质的访问和使用<br> 竞争方式：冲突之后的协调 ；<br> 令牌方式：令牌产生，占有 和释放等</p>
</li>
</ul>
<h1 id="6-1-引论和服务"><a href="#6-1-引论和服务" class="headerlink" title="6.1 引论和服务"></a>6.1 引论和服务</h1><h2 id="链路层-导论"><a href="#链路层-导论" class="headerlink" title="链路层: 导论"></a>链路层: 导论</h2><p>一些术语:</p>
<ul>
<li><strong>主机和路由器是节点（网桥和交换机也是）: nodes</strong></li>
<li><strong>沿着通信路径,连接个相邻节点通信信道的是链路:links</strong><ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li><strong>第二层协议数据单元帧frame，封装数据报</strong></li>
</ul>
<p><strong>数据链路层负责==从一个节点通过链路将(帧中的）数据报发送到相邻的物理节点(一个子网内部的2节点)==</strong></p>
<h2 id="链路层-上下文"><a href="#链路层-上下文" class="headerlink" title="链路层: 上下文"></a>链路层: 上下文</h2><ul>
<li><p>数据报（分组）在不同的链路上<strong>以不同的链路协议</strong>传送：<br> <strong>第一跳链路</strong>：以太网<br> <strong>中间链路</strong>：帧中继链路<br> <strong>最后一跳</strong>：802.11  (无线局域网通用的标准)</p>
</li>
<li><p>不同的链路协议提供不同 的服务</p>
<ul>
<li>e.g.,比如在链路层上提供（ 或没有）可靠数据传送</li>
</ul>
</li>
</ul>
<p>传输类比</p>
<ul>
<li>从Princeton到Lausanne <ul>
<li>轿车: Princeton to JFK </li>
<li>飞机: JFK to Geneva </li>
<li>火车: Geneva to Lausanne </li>
</ul>
</li>
<li><strong>旅行者=数据报</strong>datagram </li>
<li><strong>交通段=通信链路</strong> communication link </li>
<li><strong>交通模式=链路层协议</strong> : 数 据链路层和局域网 protocol </li>
<li><strong>票务代理=路由算法</strong> routing algorithm</li>
</ul>
<h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><ul>
<li><strong>成帧，链路接入</strong>：<ul>
<li>将数据报封装在帧中，加上帧头、帧尾部 </li>
<li>如果采用的是共享性介质，信道接入获得信道访问权 </li>
<li>在帧头部使用“MAC”（物理）地址来标示源和目的<br>• 不同于IP地址</li>
</ul>
</li>
<li><strong>在（一个网络内）相邻两个节点完成可靠数据传递</strong><ul>
<li>已经学过了（第三章） ——  传输层</li>
<li>在低出错率的链路上（光纤和双绞线电缆）很少使用</li>
<li>在无线链路经常使用：出错率高</li>
</ul>
</li>
</ul>
<p><strong>==Q: 为什么在链路层和传输层都实现了可靠性？==</strong></p>
<blockquote>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务<br>一个特定的链路层只是提供其中一部分的服务</p>
</blockquote>
<ul>
<li><p>在相邻节点间（一个子网内）进行可靠的转发</p>
<ul>
<li>我们已经学习过（见第三章）！</li>
<li><strong>在低差错链路上很少使用 (光纤,一些双绞线)</strong><ul>
<li>出错率低，没有必要在每一个帧中做差错控制的工作，协议复杂<ul>
<li>发送端对每一帧进行差错控制编码，根据反馈做相应的动作 </li>
<li>接收端进行差错控制解码，反馈给发送端（ACK，NAK）</li>
</ul>
</li>
<li>在本层放弃可靠控制的工作，在网络层或者是传输层做可靠控制的工作，或者根本就不做可靠控制的工作</li>
</ul>
</li>
<li>在高差错链路上需要进行可靠的数据传送<ul>
<li>高差错链路：无线链路：<ul>
<li><strong>Q：为什么要在采用无线链路的网络上，链路层做可靠数据传输工作 ；还要在传输层做端到端的可靠性工作？</strong></li>
<li>==<strong>原因：出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</strong>==   —— 出错率较大的时候，传到上层再纠错代价大<ul>
<li><strong>如不做local recovery 工作，总体代价大</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>流量控制：</strong> </p>
<ul>
<li>使得相邻的发送和接收方节点的速度匹配 </li>
</ul>
</li>
<li><strong>错误检测：</strong> <ul>
<li>差错由信号衰减和噪声引起 </li>
<li>接收方检测出的错误: <ul>
<li>通知发送端进行重传或丢弃帧 </li>
</ul>
</li>
</ul>
</li>
<li><strong>差错纠正:</strong> <ul>
<li>接收端检查和纠正bit错误，不通过重传来纠正错误 </li>
</ul>
</li>
<li><strong>半双工和全双工:</strong> <ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<h2 id="链路层在哪里实现？"><a href="#链路层在哪里实现？" class="headerlink" title="链路层在哪里实现？"></a>链路层在哪里实现？</h2><ul>
<li>在每一个主机上 <ul>
<li>也在每个路由器上 </li>
<li>交换机的每个端口上</li>
</ul>
</li>
<li>链路层功能在“适配器”上 实现 (aka network interface card NIC) 或 者在一个芯片组上<ul>
<li>以太网卡，802.11 网卡 ; 以太网芯片组 </li>
<li>实现链路层和相应的物 理层功能</li>
</ul>
</li>
<li>接到主机的系统总线上</li>
<li>硬件、软件和固件的综合 体</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002224550874.png" alt="image-20211002224550874"></p>
<h2 id="适配器通信"><a href="#适配器通信" class="headerlink" title="适配器通信"></a>适配器通信</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002224607535.png" alt="image-20211002224607535"></p>
<ul>
<li>发送方: <ul>
<li>在帧中封装数据报 </li>
<li>加上差错控制编码，实现RDT和流量控制功能等</li>
</ul>
</li>
<li>接收方：<ul>
<li>检查有无出错，执行rdt和流量控制功能等 </li>
<li>解封装数据报，将至交 给上层</li>
</ul>
</li>
</ul>
<h1 id="6-2-差错检测和纠正"><a href="#6-2-差错检测和纠正" class="headerlink" title="6.2 差错检测和纠正"></a>6.2 差错检测和纠正</h1><h2 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h2><p>EDC=差错检测和纠正位（冗余位）</p>
<p>D =数据由差错检测保护，可以包含头部字段错误检测不是100%可靠的!</p>
<p>错误检测不是100%可靠的! </p>
<ul>
<li>协议会漏检一些错误，但是很少 </li>
<li>更长的EDC字段可以得到更好的检测和纠正效果</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002224745844.png" alt="image-20211002224745844"></p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002224811357.png" alt="image-20211002224811357"></p>
<h2 id="Internet校验和"><a href="#Internet校验和" class="headerlink" title="Internet校验和"></a>Internet校验和</h2><p>目标: 检测在传输报文段时的错误（如位翻转），（注：仅仅用在传输层）</p>
<ul>
<li><p>发送方: </p>
<ul>
<li>将报文段看成16-bit整 数 </li>
<li>报文段的校验和: 和 (1’ 的补码和) </li>
<li>发送方将checksum的 值放在‘UDP校验和’ 字段</li>
</ul>
</li>
<li><p>接收方:</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查是否与携带校验和字 段值一致: <ul>
<li>不一致：检出错误 </li>
<li>一致：没有检出错误，但可能还是有错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有更简单的检查方法 全部加起来看是不是全1</p>
<h2 id="检验和：CRC（循环冗余校验）"><a href="#检验和：CRC（循环冗余校验）" class="headerlink" title="检验和：CRC（循环冗余校验）"></a>检验和：CRC（循环冗余校验）</h2><p>1、模二运算 —— 异或运算</p>
<p>2、位串的两种表示</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002225934163.png" alt="image-20211002225934163"></p>
<p>3、生成多项式，r次方</p>
<p><strong>G = X^3 + 1         r + 1位</strong>             例子：1001</p>
<p>4、发送方:根据r位 CRC 计算r位冗余位，使得</p>
<ul>
<li>正好被 G整除 (modulo 2) </li>
<li>接收方知道 G, 将除以 G. 如果非0余数: 检查出错误!</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul>
<p><strong>==D  ——发送的数据 （左移r位）+  R —— 冗余位 （r位）==</strong></p>
<p><strong>==G —— 生成多项式（r - 1次方)==</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002230457145.png" alt="image-20211002230457145"></p>
<ul>
<li>强大的差错检测码</li>
<li>将数据比特 D, 看成是二进制的数据</li>
<li>生成多项式G：双方协商r+1位模式（r次方）<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li>目标:选择r位 CRC附加位R，使得<ul>
<li>正好被 G整除 (modulo 2) </li>
<li>接收方知道 G, 将 除以 G. 如果非0余数: 检查出错误!</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul>
</li>
<li>实际中广泛使用（以太网、802.11 WiFi、ATM）</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002225357330.png" alt="image-20211002225357330"></p>
<h2 id="CRC-例子"><a href="#CRC-例子" class="headerlink" title="CRC 例子"></a>CRC 例子</h2><ul>
<li>需要: D.2r <strong>XOR</strong> R = nG</li>
<li>等价于: D.2r = nG <strong>XOR</strong> R </li>
<li>等价于: 两边同除G 得到余数 R=.. <img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002230905492.png" alt="image-20211002230905492"></li>
</ul>
<p>remainder —— 余数 、当余数R不足r位，补0</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002230858718.png" alt="image-20211002230858718"></p>
<h2 id="CRC性能分析"><a href="#CRC性能分析" class="headerlink" title="CRC性能分析"></a>CRC性能分析</h2><ul>
<li>突发错误和突发长度</li>
<li>CRC检错性能描述<ul>
<li><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002231306540.png" alt="image-20211002231306540"></li>
</ul>
</li>
</ul>
<h1 id="6-3-多点访问协议"><a href="#6-3-多点访问协议" class="headerlink" title="6.3 多点访问协议"></a>6.3 多点访问协议</h1><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>两种类型的链路（一个子网内部链路连接形式）：</p>
<ul>
<li>点对点 <ul>
<li>拨号访问的PPP </li>
<li>以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li>广播 (共享线路或媒体) <ul>
<li>传统以太网 </li>
<li>HFC上行链路 </li>
<li>802.11无线局域网</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211002231421347.png" alt="image-20211002231421347"></p>
<h2 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h2><ul>
<li>单个共享的广播型链路</li>
<li>2个或更多站点同时传送: 冲突（collision）<ul>
<li>多个节点在同一个时刻发送，则会收到2个或多个信号 叠加</li>
</ul>
</li>
</ul>
<p><strong>==多路访问协议（介质访问控制协议：MAC）==</strong></p>
<ul>
<li><strong>分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送？</strong></li>
<li>关于共享控制的通信必须用借助信道本身传输！ <ul>
<li>没有带外的信道，各节点使用其协调信道使用 </li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
<h2 id="理想的多路访问协议"><a href="#理想的多路访问协议" class="headerlink" title="理想的多路访问协议"></a>理想的多路访问协议</h2><ul>
<li>给定：Rbps带宽的广播信道</li>
</ul>
<p>必要条件：</p>
<ol>
<li><p>当一个节点要发送时，可以<strong>以R速率发送</strong>. </p>
</li>
<li><p>当M个节点要发送，每个可以<strong>以R/M的平均速率</strong>发送 </p>
</li>
<li>完全分布的: <ol>
<li><strong>没有特殊节点协调发送</strong> </li>
<li><strong>没有时钟和时隙的同步</strong></li>
</ol>
</li>
<li>简单</li>
</ol>
<h2 id="MAC（媒体访问控制）协议：分类"><a href="#MAC（媒体访问控制）协议：分类" class="headerlink" title="MAC（媒体访问控制）协议：分类"></a>MAC（媒体访问控制）协议：分类</h2><p>3大类</p>
<ul>
<li><strong>信道划分</strong><br>o把信道划分成小片（时间、频率、编码)<br>o分配片给每个节点专用</li>
<li><strong>随机访问</strong><br>o信道不划分，允许冲突<br>○冲突后恢复</li>
<li><strong>依次轮流</strong><br>o节点依次轮流<br>○但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
<h3 id="a-信道划分MAC协议：TDMA-时分复用"><a href="#a-信道划分MAC协议：TDMA-时分复用" class="headerlink" title="a.信道划分MAC协议：TDMA 时分复用"></a>a.信道划分MAC协议：TDMA 时分复用</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010402398.png" alt="image-20211003010402398"></p>
<h3 id="a-信道划分MAC协议：FDMA-频分复用"><a href="#a-信道划分MAC协议：FDMA-频分复用" class="headerlink" title="a.信道划分MAC协议：FDMA  频分复用"></a>a.信道划分MAC协议：FDMA  频分复用</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010449653.png" alt="image-20211003010449653"></p>
<h3 id="a-码分多路访问（CDMA）"><a href="#a-码分多路访问（CDMA）" class="headerlink" title="a.码分多路访问（CDMA）"></a>a.码分多路访问（CDMA）</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010510131.png" alt="image-20211003010510131"></p>
<h3 id="b-随机存取协议"><a href="#b-随机存取协议" class="headerlink" title="b.随机存取协议"></a>b.随机存取协议</h3><p>检错冲突   与  冲突解决/冲突避免</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010538701.png" alt="image-20211003010538701"></p>
<h4 id="b-1-时隙ALOHA"><a href="#b-1-时隙ALOHA" class="headerlink" title="b.1 时隙ALOHA"></a>b.1 时隙ALOHA</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010613208.png" alt="image-20211003010613208"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010707726.png" alt="image-20211003010707726"></p>
<p>时隙ALOHA的效率( Efficiency )</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010722429.png" alt="image-20211003010722429"></p>
<h4 id="b-2-纯ALOHA-非时隙"><a href="#b-2-纯ALOHA-非时隙" class="headerlink" title="b.2 纯ALOHA(非时隙)"></a>b.2 纯ALOHA(非时隙)</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010738468.png" alt="image-20211003010738468"></p>
<p>纯ALOHA的效率</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010753389.png" alt="image-20211003010753389"></p>
<h4 id="b-3-CSMA-载波侦听多路访问"><a href="#b-3-CSMA-载波侦听多路访问" class="headerlink" title="b.3 CSMA(载波侦听多路访问)"></a>b.3 CSMA(载波侦听多路访问)</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010815762.png" alt="image-20211003010815762"></p>
<p>CSMA冲突</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010833065.png" alt="image-20211003010833065"></p>
<h4 id="b-4-CSMA-CD-冲突检测"><a href="#b-4-CSMA-CD-冲突检测" class="headerlink" title="b.4 CSMA/CD(冲突检测)"></a>b.4 CSMA/CD(冲突检测)</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010844252.png" alt="image-20211003010844252"></p>
<p>CSMA/CD（冲突检测）</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010859719.png" alt="image-20211003010859719"></p>
<p>以太网CSMA/CD算法</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010933464.png" alt="image-20211003010933464"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010941312.png" alt="image-20211003010941312"></p>
<p>CSMA/CD效率</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003010953336.png" alt="image-20211003010953336"></p>
<h4 id="b-5-无线局域网-CSMA-CA"><a href="#b-5-无线局域网-CSMA-CA" class="headerlink" title="b.5 无线局域网 CSMA/CA"></a>b.5 无线局域网 CSMA/CA</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011006144.png" alt="image-20211003011006144"></p>
<p>无线局域网中的 MAC：CSMA/CA</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011019740.png" alt="image-20211003011019740"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011031282.png" alt="image-20211003011031282"></p>
<p>冲突避免(续)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011105533.png" alt="image-20211003011105533"></p>
<p>冲突避免：RTS-CTS 交换</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011156385.png" alt="image-20211003011156385"></p>
<h4 id="b-5-线缆接入网络"><a href="#b-5-线缆接入网络" class="headerlink" title="b.5 线缆接入网络"></a>b.5 线缆接入网络</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011225369.png" alt="image-20211003011225369"></p>
<h4 id="c-轮流-Taking-Turns-MAC协议"><a href="#c-轮流-Taking-Turns-MAC协议" class="headerlink" title="c.轮流(Taking Turns)MAC协议"></a>c.轮流(Taking Turns)MAC协议</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011240667.png" alt="image-20211003011240667"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011248967.png" alt="image-20211003011248967"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003011256683.png" alt="image-20211003011256683"></p>
<h2 id="MAC-协议总结"><a href="#MAC-协议总结" class="headerlink" title="MAC 协议总结"></a>MAC 协议总结</h2><p>多点接入问题：对于一个共享型介质，各个节点 如何协调对它的访问和使用? </p>
<ul>
<li>信道划分：按时间、频率或者编码 <ul>
<li>TDMA、FDMA、CDMA </li>
</ul>
</li>
<li>随机访问 (动态) <ul>
<li>ALOHA, S-ALOHA, CSMA, CSMA/CD </li>
<li>载波侦听: 在有些介质上很容易 (wire：有线介质), 但在有些 介质上比较困难 (wireless：无线) </li>
<li>CSMA/CD ：802.3 Ethernet网中使用 </li>
<li>CSMA/CA ：802.11WLAN中使用 </li>
</ul>
</li>
<li>依次轮流协议 <ul>
<li><strong>集中：由一个中心节点轮询；</strong><br><strong>分布：通过令牌控制</strong> </li>
<li>蓝牙、FDDI、令牌环</li>
</ul>
</li>
</ul>
<h1 id="6-4-LANs"><a href="#6-4-LANs" class="headerlink" title="6.4 LANs"></a>6.4 LANs</h1><p>addressing, ARP</p>
<h2 id="MAC-地址和ARP"><a href="#MAC-地址和ARP" class="headerlink" title="MAC 地址和ARP"></a>MAC 地址和ARP</h2><ul>
<li>32bit IP地址: <ul>
<li>网络层地址 </li>
<li>前n-1跳：用于使数据报到达目的IP子网 </li>
<li>最后一跳：到达子网中的目标节点</li>
</ul>
</li>
<li>LAN（MAC/物理/以太网）地址:   ——  （在一个物理网络的内部来标识每一个节点）<ul>
<li><strong>用于使帧从一个网卡传递到与其物理连接的另一个网卡 (在同一个物理网络中)</strong> </li>
<li><strong>48bit MAC地址固化在适配器的ROM，有时也可以通过软件设定</strong> </li>
<li><strong>理论上全球任何2个网卡的MAC地址都不相同</strong> </li>
<li>e.g.: 1A-2F-BB-76-09-AD  —— ( 16进制表示 (每一位代表4个bits) )</li>
</ul>
</li>
</ul>
<h3 id="网络地址和mac地址分离"><a href="#网络地址和mac地址分离" class="headerlink" title="网络地址和mac地址分离"></a>网络地址和mac地址分离</h3><ul>
<li><p>IP地址和MAC地址的作用不同<br>a) <strong>IP地址是分层的</strong>   ——  二层</p>
<ul>
<li><strong>一个子网所有站点网络号一致，路由聚集，减少路由表</strong> <ul>
<li>需要一个网络中的站点地址网络号一致，如果捆绑需要定制网卡非常麻烦 </li>
</ul>
</li>
<li><strong>希望网络层地址是配置的；IP地址完成网络到网络的交付</strong> </li>
</ul>
<p>b) <strong>mac地址是一个平面的</strong> </p>
<ul>
<li>网<strong>卡在生产时不知道被用于哪个网络，因此给网卡一个 唯一的标示，用于区分一个网络内部不同的网卡即可</strong> </li>
<li><strong>可以完成一个物理网络内部的节点到节点的数据交付</strong></li>
</ul>
</li>
</ul>
<p>从 IP 的角度，是从一个路由器到另一个路由器。<br>从 链路层的角度，是从一个网卡当另一个网卡。</p>
<ol>
<li><p>分离好处<br>a) <strong>网卡坏了，ip不变，可以捆绑到另外一个网卡的 mac上</strong><br>b) <strong>物理网络还可以除IP之外支持其他网络层协议， 链路协议为任意上层网络协议， 如IPX等</strong> </p>
</li>
<li><p>捆绑的问题<br>a) 如果仅仅使用IP地址，不用mac地址，那么它仅支持IP协议<br>b) 每次上电都要重新写入网卡 IP地址；<br>c) 另外一个选择就是不使用任何地址；不用MAC地址，则每到来一个帧都要上传到IP层次，由它判断是不是需要接受，干扰一次</p>
</li>
</ol>
<h3 id="LAN-地址和ARP"><a href="#LAN-地址和ARP" class="headerlink" title="LAN 地址和ARP"></a>LAN 地址和ARP</h3><p>局域网上每个适配器都有一个唯一的LAN地址</p>
<p>全 F 的MAX地址 是 广播地址</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003091929111.png" alt="image-20211003091929111"></p>
<ul>
<li>MAC地址由IEEE管理和分配 </li>
<li>制造商购入MAC地址空间（保证唯一性） </li>
<li>类比:<br>(a)MAC地址：社会安全号<br>(b)IP地址：通讯地址  MAC平面地址 ➜ 支持移动 </li>
<li>可以将网卡到接到其它网络  IP地址有层次-不能移动 <ul>
<li>依赖于节点连接的IP子网，与子网的网络号相同（ 有与其相连的子网相同的网络前缀）</li>
</ul>
</li>
</ul>
<h3 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP: Address Resolution Protocol"></a>ARP: Address Resolution Protocol</h3><p>问题:已知B的IP地址，如何确定B的MAC地址?</p>
<ul>
<li>在LAN上的每个IP节点都有<strong>一个ARP表</strong> </li>
<li><strong>ARP表：包括一些 LAN节点IP/MAC地 址的映射 &lt; IP address; MAC address; TTL&gt;</strong> <ul>
<li>TTL时间是指地址映射失效的时间 </li>
<li>典型是20min</li>
</ul>
</li>
</ul>
<h3 id="ARP协议：在同一个LAN-网络"><a href="#ARP协议：在同一个LAN-网络" class="headerlink" title="ARP协议：在同一个LAN (网络)"></a>ARP协议：在同一个LAN (网络)</h3><ul>
<li>A要发送帧给B(B的IP地址 已知)， 但B的MAC地址不 在A的ARP表中 </li>
<li>A广播包含B的IP地址的 ARP查询包 <ul>
<li>Dest MAC address = FF-FF-FF-FF-FF-FF </li>
<li>LAN上的所有节点都会收到 该查询包 </li>
</ul>
</li>
<li>B接收到ARP包，回复A自 己的MAC地址 <ul>
<li>帧发送给A </li>
<li>用A的MAC地址（单播）</li>
</ul>
</li>
<li>A在自己的ARP表中，缓存 IP-to-MAC地址映射关系 ，直到信息超时 <ul>
<li>软状态: 靠定期刷新维持的系统状态 </li>
<li>定期刷新周期之间维护的状态信息可能和原有系统不一 致 </li>
</ul>
</li>
<li>ARP是即插即用的 <ul>
<li>节点自己创建ARP的表项 </li>
<li>无需网络管理员的干预</li>
</ul>
</li>
</ul>
<h3 id="路由到其他LAN"><a href="#路由到其他LAN" class="headerlink" title="路由到其他LAN"></a>路由到其他LAN</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003092755106.png" alt="image-20211003092755106"></p>
<h3 id="编址：路由到其他LAN"><a href="#编址：路由到其他LAN" class="headerlink" title="编址：路由到其他LAN"></a>编址：路由到其他LAN</h3><ul>
<li><p><strong>A创建数据报，源IP地址：A；目标IP地址：B</strong>           封装一层</p>
</li>
<li><p><strong>A创建一个链路层的帧，目标MAC地址是R，该帧包含A 到B的IP数据报</strong></p>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003092846728.png" alt="image-20211003092846728"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003093159324.png" alt="image-20211003093159324"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003093207363.png" alt="image-20211003093207363"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>目前最主流的LAN技术：98%占有率 </li>
<li>廉价：30元RMB 100Mbps！ </li>
<li>最早广泛应用的LAN技术 </li>
<li>比令牌网和ATM网络简单、廉价 </li>
<li>带宽不断提升：10M, 100M, 1G, 10G</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003093457375.png" alt="image-20211003093457375"></p>
<h3 id="以太网：物理拓扑"><a href="#以太网：物理拓扑" class="headerlink" title="以太网：物理拓扑"></a>以太网：物理拓扑</h3><ul>
<li><strong>总线：在上个世纪90年代中期很流行</strong> <ul>
<li>所有节点在一个碰撞域内，一次只允许一个节点发送 </li>
<li><strong>可靠性差，如果介质破损，截面形成信号的反射，发送节点误认为 是冲突，总是冲突</strong> </li>
</ul>
</li>
<li><strong>星型：目前最主流</strong> <ul>
<li><strong>连接选择: hub(无法并行，一发全收) 或者 switch (并行)</strong></li>
<li>现在一般是交换机(switch)在中心 </li>
<li><strong>每个节点以及相连的交换机端口使用（独立的）以太网协议（不会和其他节点的发送产生碰撞）</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003093613325.png" alt="image-20211003093613325"></p>
<h3 id="以太帧结构"><a href="#以太帧结构" class="headerlink" title="以太帧结构"></a>以太帧结构</h3><p>发送方适配器在以太网帧中封装IP数据报， 或其他网络层协议数据单元</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003093826481.png" alt="image-20211003093826481"></p>
<p>前导码: </p>
<ul>
<li><strong>7B 10101010 + 1B 10101011</strong> </li>
<li><p><strong>用来同步接收方和发送方的时钟速率</strong> </p>
<ul>
<li>使得接收方将自己的时钟调到发送端的时钟 </li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul>
</li>
<li><p><strong>地址：6字节源MAC地址，目标MAC地址</strong> </p>
<ul>
<li>如：帧目标地址=本站MAC地址，或是广播地址， 接收，递交帧中的数据到网络层 </li>
<li>否则，适配器忽略该帧 </li>
</ul>
</li>
<li><strong>类型：指出高层协(大多情况下是IP，但也支持其它网络层协议Novell IPX和AppleTalk)</strong> </li>
<li><strong>CRC：在接收方校验</strong> <ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
<h3 id="以太网：无连接、不可靠的服务"><a href="#以太网：无连接、不可靠的服务" class="headerlink" title="以太网：无连接、不可靠的服务"></a>以太网：无连接、不可靠的服务</h3><ul>
<li><strong>==无连接：帧传输前，发送方和接收方之间没有握手==</strong> </li>
<li><strong>==不可靠：接收方适配器不发送ACKs或NAKs给发送方==</strong> <ul>
<li>递交给网络层的数据报流可能有gap </li>
<li>如上层使用像传输层TCP协议这样的rdt，gap会被补上( 源主机，TCP实体) </li>
<li>否则，应用层就会看到gap </li>
</ul>
</li>
<li>==<strong>以太网的MAC协议：采用二进制退避的CSMA/CD 介质访问控制形式</strong>==</li>
</ul>
<h3 id="802-3-以太网标准：链路和物理层"><a href="#802-3-以太网标准：链路和物理层" class="headerlink" title="802.3 以太网标准：链路和物理层"></a>802.3 以太网标准：链路和物理层</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003095719135.png" alt="image-20211003095719135"></p>
<h3 id="以太网使用CSMA-CD"><a href="#以太网使用CSMA-CD" class="headerlink" title="以太网使用CSMA/CD"></a>以太网使用CSMA/CD</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003095730238.png" alt="image-20211003095730238"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003095801368.png" alt="image-20211003095801368"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003095826706.png" alt="image-20211003095826706"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003095900060.png" alt="image-20211003095900060"></p>
<h3 id="10BaseT-and-100BaseT"><a href="#10BaseT-and-100BaseT" class="headerlink" title="10BaseT and 100BaseT"></a>10BaseT and 100BaseT</h3><ul>
<li>100 Mbps 速率 也被称之为 “fast ethernet”        Base  基带信号</li>
<li>T代表双绞线 </li>
<li>节点连接到HUB上: “star topology”物理上星型 <ul>
<li><strong>逻辑上总线型，盒中总线</strong>   一发全收，一次只能发一次</li>
</ul>
</li>
<li>节点和HUB间的最大距离是100 m</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003095952932.png" alt="image-20211003095952932"></p>
<h3 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a>Hubs</h3><ul>
<li>Hubs 本质上是物理层的中继器: <ul>
<li>从一个端口收，转发到所有其他端口 </li>
<li>速率一致  没有帧的缓存 </li>
<li>在hub端口上没有CSMA/CD机制:适配器检测冲突 </li>
<li>提供网络管理功能</li>
</ul>
</li>
</ul>
<h3 id="Manchester-编码-——-物理层"><a href="#Manchester-编码-——-物理层" class="headerlink" title="Manchester 编码  —— 物理层"></a>Manchester 编码  —— 物理层</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003100140814.png" alt="image-20211003100140814"></p>
<ul>
<li>在 10BaseT中使用 </li>
<li>每一个bit的位时中间有一个信号跳变 </li>
<li>允许在接收方和发送方节点之间进行时钟同步 <ul>
<li>节点间不需要集中的和全局的时钟 </li>
</ul>
</li>
<li>10Mbps，使用20M带宽，效率50% </li>
<li>Hey, this is physical-layer stuff!</li>
</ul>
<h3 id="100BaseT中的4b5b编码"><a href="#100BaseT中的4b5b编码" class="headerlink" title="100BaseT中的4b5b编码"></a>100BaseT中的4b5b编码</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003102620272.png" alt="image-20211003102620272"></p>
<h3 id="千兆以太网"><a href="#千兆以太网" class="headerlink" title="千兆以太网"></a>千兆以太网</h3><p> 采用标准的以太帧格式<br> 允许点对点链路和共享广播信道<br> 物理编码：8b10b编码<br> 在共享模式，继续使用CSMA/CD MAC技术 ，节点间需要较短距离以提高利用率<br> 交换模式：全双工千兆可用于点对点链路<br> 站点使用专用信道，基本不会冲突，效率高<br> 除非发往同一个目标站点<br> 10 Gbps now !</p>
<h2 id="802-11WLAN"><a href="#802-11WLAN" class="headerlink" title="802.11WLAN"></a>802.11WLAN</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003102721615.png" alt="image-20211003102721615"></p>
<h3 id="802-11-LAN-体系结构"><a href="#802-11-LAN-体系结构" class="headerlink" title="802.11 LAN 体系结构"></a>802.11 LAN 体系结构</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003102741419.png" alt="image-20211003102741419"></p>
<h2 id="switches"><a href="#switches" class="headerlink" title="switches"></a>switches</h2><h3 id="Hub：集线器"><a href="#Hub：集线器" class="headerlink" title="Hub：集线器"></a>Hub：集线器</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003102803772.png" alt="image-20211003102803772"></p>
<h3 id="交换机-——-路由层面-主机-是看不到交换机的，透明的"><a href="#交换机-——-路由层面-主机-是看不到交换机的，透明的" class="headerlink" title="交换机  ——  路由层面(主机)是看不到交换机的，透明的"></a>交换机  ——  路由层面(主机)是看不到交换机的，透明的</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003102848810.png" alt="image-20211003102848810"></p>
<h3 id="交换机：多路同时传输"><a href="#交换机：多路同时传输" class="headerlink" title="交换机：多路同时传输"></a>交换机：多路同时传输</h3><ul>
<li><strong>主机有一个专用和直接到交换机的连接</strong> </li>
<li><strong>交换机缓存到来的帧</strong> </li>
<li><strong>对每个帧进入的链路使用以太网协议，没有碰撞；全双工</strong> <ul>
<li>每条链路都是一个独立的 碰撞域 </li>
<li>MAC协议在其中的作用弱 化了 </li>
</ul>
</li>
<li><strong>交换：A-to-A’ 和 B-to-B’ 可 以同时传输，没有碰撞</strong></li>
</ul>
<h3 id="交换机转发表"><a href="#交换机转发表" class="headerlink" title="交换机转发表"></a>交换机转发表</h3><ul>
<li><p>Q:交换机如何知道通过接口1到达A，通过接口5到达B’?</p>
</li>
<li><p>A:每个交换机都有一个交换表switch table，每个表项:</p>
<p><strong>(主机的MAC地址,到达该MAC经过的接口，时戳)</strong><br><strong>比较像路由表!</strong></p>
</li>
<li><p>Q: 每个表项是如何创建的？如何维护的？</p>
<p><strong>有点像路由协议?</strong></p>
</li>
</ul>
<h3 id="交换机：自学习"><a href="#交换机：自学习" class="headerlink" title="交换机：自学习"></a>交换机：自学习</h3><ul>
<li><p>交换机通过学习得到哪些 主机（mac地址）可以通 过哪些端口到达 </p>
<ul>
<li><strong>当接收到帧，交换机 学习到发送站点所在 的端口（网段）</strong> </li>
<li><strong>记录发送方MAC地址/ 进入端口映射关系， 在交换表中</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003104905022.png" alt="image-20211003104905022"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003104914637.png" alt="image-20211003104914637"></p>
</li>
</ul>
<h3 id="交换机：过滤／转发"><a href="#交换机：过滤／转发" class="headerlink" title="交换机：过滤／转发"></a>交换机：过滤／转发</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003103245720.png" alt="image-20211003103245720"></p>
<h3 id="自学习，转发的例子-——-不知道，泛洪"><a href="#自学习，转发的例子-——-不知道，泛洪" class="headerlink" title="自学习，转发的例子  —— 不知道，泛洪"></a>自学习，转发的例子  —— 不知道，泛洪</h3><p>帧的目标： A’, 不知道 其位置在哪：泛洪 A’ A </p>
<ul>
<li>知道目标A对应的链路 ： A’ 4 60 选择性发送到那个端 口</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105023894.png" alt="image-20211003105023894"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105040787.png" alt="image-20211003105040787"></p>
<h3 id="交换机级联"><a href="#交换机级联" class="headerlink" title="交换机级联"></a>交换机级联</h3><p>交换机可被级联到一起</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105117255.png" alt="image-20211003105117255"></p>
<p>Q: A to G的发送 – 交换机S1 如何知道经过从 S4 和S3最终达到F?<br> A: 自学习! (和在一个交换机联接所有站点一 样!)</p>
<h3 id="多交换机自学习的例子"><a href="#多交换机自学习的例子" class="headerlink" title="多交换机自学习的例子"></a>多交换机自学习的例子</h3><p>假设C向I发送帧，I给C应答</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105129108.png" alt="image-20211003105129108"></p>
<p> Q: 显示交换表和帧在S1 , S2 , S3 , S4的转发</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105230290.png" alt="image-20211003105230290"></p>
<h2 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs. 路由器"></a>交换机 vs. 路由器</h2><ul>
<li>都是存储转发设备，但层次不同 <ul>
<li>交换机：链路层设备（检查 链路层头部） </li>
<li>路由器：网络层设备（检查 网络层的头部）</li>
</ul>
</li>
<li>都有转发表： <ul>
<li>交换机：<strong>维护交换表，按照 MAC地址转发</strong> <ul>
<li>执行过滤、自学习和生成树算法 </li>
<li><strong>即插即用；二层设备，速率高</strong> </li>
<li>执行生成树算法，限制广播帧的 转发 </li>
<li><strong>ARP表项随着站点数量增多而增多</strong> </li>
</ul>
</li>
<li>路由器：续</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105503237.png" alt="image-20211003105503237"></p>
<ul>
<li>路由器维护路由表，执行路由算法 <ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络 </li>
<li>对广播分组做限制 </li>
<li><strong>不是即插即用的，配置网络地址（子网前缀）</strong> </li>
<li><strong>三层设备，速率低</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105603439.png" alt="image-20211003105603439"></p>
<h2 id="VLANS-虚拟局域网"><a href="#VLANS-虚拟局域网" class="headerlink" title="VLANS 虚拟局域网"></a>VLANS 虚拟局域网</h2><h3 id="VLANs-动机"><a href="#VLANs-动机" class="headerlink" title="VLANs: 动机"></a>VLANs: 动机</h3><p>考虑场景： </p>
<ul>
<li>CS用户搬到EE大楼办公室 ，但是希望连接到CS的交 换机? </li>
<li>接到多个交换机上 <ul>
<li>麻烦和浪费：96端口 /10个有用 </li>
</ul>
</li>
<li>如果都接到一个交换机上 ，在一个广播域 <ul>
<li>所有的层2广播流量 (ARP, DHCP,不知道 MAC地址对应端口的帧 )都必须穿过整个LAN </li>
<li>安全性/私密性的问题</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105820232.png" alt="image-20211003105820232"></p>
<h3 id="基于端口的VLAN-——-一些端口-mac地址-通过虚拟交换机连在一起"><a href="#基于端口的VLAN-——-一些端口-mac地址-通过虚拟交换机连在一起" class="headerlink" title="基于端口的VLAN —— 一些端口/mac地址 通过虚拟交换机连在一起"></a>基于端口的VLAN —— 一些端口/mac地址 通过虚拟交换机连在一起</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003105839184.png" alt="image-20211003105839184"></p>
<h1 id="6-5-链路虚拟化：MPLS"><a href="#6-5-链路虚拟化：MPLS" class="headerlink" title="6.5 链路虚拟化：MPLS"></a>6.5 链路虚拟化：MPLS</h1><h2 id="MPLS概述-——-标签分发"><a href="#MPLS概述-——-标签分发" class="headerlink" title="MPLS概述 —— 标签分发"></a>MPLS概述 —— 标签分发</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003110011423.png" alt="image-20211003110011423"></p>
<h1 id="6-6-数据中心网络"><a href="#6-6-数据中心网络" class="headerlink" title="6.6 数据中心网络"></a>6.6 数据中心网络</h1><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003110123038.png" alt="image-20211003110123038"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003110142423.png" alt="image-20211003110142423"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003110203396.png" alt="image-20211003110203396"></p>
<h1 id="6-7-a-day-in-the-life-of-web-request"><a href="#6-7-a-day-in-the-life-of-web-request" class="headerlink" title="6.7 a day in the life of web request"></a>6.7 a day in the life of web request</h1><p>回顾: 页面请求的历程 </p>
<ul>
<li>Top-down的协议栈旅程结束了! <ul>
<li>应用层、运输层、网络层和链路层 </li>
</ul>
</li>
<li>以一个web页面请求的例子: 综述! <ul>
<li>目标: 标示、回顾和理解涉及到的协议（所有层次 ），以一个看似简单的场景: 请求www页面 </li>
<li>场景：学生在校园启动一台笔记本电脑：请求和接 受www.google.com</li>
</ul>
</li>
</ul>
<h2 id="日常场景"><a href="#日常场景" class="headerlink" title="日常场景"></a>日常场景</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003110344335.png" alt="image-20211003110344335"></p>
<h2 id="日常场景：…-连接到互联网"><a href="#日常场景：…-连接到互联网" class="headerlink" title="日常场景：… 连接到互联网"></a>日常场景：… 连接到互联网</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003111137748.png" alt="image-20211003111137748"></p>
<ul>
<li>笔记本需要一个IP地址，第一跳路由器的IP地址，DNS的地址:采用DHCP</li>
<li>DHCP请求被封装在UDP中，封装在IP，封装在802.3以太网帧中</li>
<li>以太网的帧在LAN上广播<br>(dest: FFFFFFFFFFFF)，被运行中的DHCP服务器接收到</li>
<li>以太网帧中解封装IP分组，解封装UDP，解封装DHCP</li>
</ul>
<ul>
<li>DHCP服务器生成DHCPACK包括客户端IP地址，第一跳路由器P地址和DNS名字服务器地址</li>
<li>在DHCP服务器封装，帧通过LAN转发(交换机学习)在客户端段解封装</li>
<li>客户端接收DHCP ACK应答</li>
</ul>
<p>客户端有了IP地址，知道了DNS域名服务器的名字和IP地址 第一跳路由器的IP地址</p>
<h2 id="日常场景……-ARP-DNS之前-HTTP之前"><a href="#日常场景……-ARP-DNS之前-HTTP之前" class="headerlink" title="日常场景…… ARP (DNS之前, HTTP之前)"></a>日常场景…… ARP (DNS之前, HTTP之前)</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003111146617.png" alt="image-20211003111146617"></p>
<ul>
<li>在发送HTTP request请求之前, 需要知道www.google.com的IP地 址: DNS </li>
<li>DNS查询被创建，封装在UDP段中 ，封装在IP数据报中，封装在以 太网的帧中. 将帧传递给路由器 ，但是需要知道路由器的接口： MAC地址：ARP </li>
<li>ARP查询广播，被路由器接收， 路由器用ARP应答，给出其IP地 址某个端口的MAC地址 </li>
<li>客户端现在知道第一跳路由器 MAC地址，所以可以发送DNS查 询帧了</li>
</ul>
<h2 id="日常场景：使用DNS"><a href="#日常场景：使用DNS" class="headerlink" title="日常场景：使用DNS"></a>日常场景：使用DNS</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003111215380.png" alt="image-20211003111215380"></p>
<ul>
<li>包含了DNS查询的IP数据报 通过LAN交换机转发，从客 户端到第一跳路由器</li>
<li>IP 数据报被转发，从校园到达 comcast网络，路由（路由表被 RIP，OSPF，IS-IS 和/或BGP协 议创建）到DNS服务器 </li>
<li>被DNS服务器解封装 </li>
<li>DNS服务器回复给客户端： www.google.com的IP地址</li>
</ul>
<h2 id="日常场景：-…TCP连接携带HTTP报文"><a href="#日常场景：-…TCP连接携带HTTP报文" class="headerlink" title="日常场景： …TCP连接携带HTTP报文"></a>日常场景： …TCP连接携带HTTP报文</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003111254982.png" alt="image-20211003111254982"></p>
<ul>
<li>为了发送HTTP请求，客户端打开到达web服务器的TCP socket</li>
<li>TCP SYN段(3次握手的第1次握手)域间路由到web服务器</li>
<li>web服务器用TCP SYNACK应答(3次握手的第2次握手)</li>
<li>TCP连接建立了!</li>
</ul>
<h3 id="日常场景：-……-HTTP请求和应答"><a href="#日常场景：-……-HTTP请求和应答" class="headerlink" title="日常场景： …… HTTP请求和应答"></a>日常场景： …… HTTP请求和应答</h3><ul>
<li>HTTP请求发送到TCPsocket中</li>
<li>IP数据报包含HTTP请求，最终路由到www.google.com</li>
<li>web服务器用HTTP应答回应(包括请求的页面)</li>
<li>IP数据报包含HTTP应答最后被路由到客户端</li>
</ul>
<h1 id="第6章：总结"><a href="#第6章：总结" class="headerlink" title="第6章：总结"></a>第6章：总结</h1><ul>
<li>数据链路层服务背后的原理: <ul>
<li>检错、纠错 </li>
<li>共享广播式信道：多路访问 </li>
<li>链路编址 </li>
</ul>
</li>
<li>各种链路层技术的实例和实现 <ul>
<li>Ethernet </li>
<li>交换式LANS, VLANs </li>
<li>虚拟成链路层的网络: MPLS </li>
</ul>
</li>
<li>综合：一个web页面请求的日常场景</li>
</ul>
<ul>
<li>自上而下的协议栈的旅行<strong>结束</strong>了 (除了物理层) </li>
<li>坚实地理解了网络的原理和实践 </li>
<li>….. 可以在这里停一下 … … 但是仍然还有很多有趣的话题! <ul>
<li>无线网络 </li>
<li>多媒体 </li>
<li>网络安全</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第二章 应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：18:59:38" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第2章-应用层"><a href="#第2章-应用层" class="headerlink" title="第2章 应用层"></a>第2章 应用层</h1><p>[TOC]</p>
<h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p><strong>网络应用的体系结构</strong></p>
<p>可能的应用架构:<br>客户-服务器模式（C/S:client/server)<br>对等模式(P2P:Peer To Peer)<br>混合体:客户-服务器和对等体系结构</p>
<h3 id="客户-服务器（C-S）体系结构"><a href="#客户-服务器（C-S）体系结构" class="headerlink" title="客户-服务器（C/S）体系结构"></a>客户-服务器（C/S）体系结构</h3><p>服务器:</p>
<ul>
<li>一直运行</li>
<li>固定的IP地址和周知的端口号（约定)</li>
<li>扩展性:服务器场数据中心进行扩展扩展性差</li>
</ul>
<p>客户端:</p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接)</li>
<li>可能是动态IP地址</li>
<li>不直接与其它客户端通信</li>
</ul>
<p><strong>缺点 ：可拓展性差    达到一定能限（阈值），性能暴跌    可靠性差</strong></p>
<h3 id="对等体（P2P）体系结构"><a href="#对等体（P2P）体系结构" class="headerlink" title="对等体（P2P）体系结构"></a>对等体（P2P）体系结构</h3><ul>
<li>(几乎）没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器<ul>
<li><strong>自扩展性-新peer节点带来新的</strong><br><strong>服务能力，当然也带来新的服务请求</strong></li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变地址<ul>
<li><strong>难以管理（缺点）</strong></li>
</ul>
</li>
<li>例子:Gnutella，迅雷</li>
</ul>
<h3 id="C-S和P2P体系结构的混合体"><a href="#C-S和P2P体系结构的混合体" class="headerlink" title="C/S和P2P体系结构的混合体"></a>C/S和P2P体系结构的混合体</h3><p>Napster </p>
<ul>
<li><strong>文件搜索：集中 </strong><ul>
<li><strong> 主机在中心服务器上注册其资源</strong> </li>
<li><strong> 主机向中心服务器查询资源位置</strong> </li>
</ul>
</li>
<li><strong>文件传输：P2P</strong> <ul>
<li><strong> 任意Peer节点之间</strong> </li>
</ul>
</li>
</ul>
<p>即时通信 </p>
<ul>
<li><strong>在线检测：集中</strong> <ul>
<li>当用户上线时，向中心服务器注册其IP地址 </li>
<li>用户与中心服务器联系，以找到其在线好友的位置 </li>
</ul>
</li>
<li><strong>两个用户之间聊天：P2P</strong></li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程:在主机上运行的应用程序</p>
<ul>
<li>在同一个主机内，使用<br><strong>进程间通信机制</strong>通信（操作系统定义)</li>
<li>不同主机，通过<strong>交换报文(Message）</strong>来通信<ul>
<li>使用OS提供的通信服<br>务</li>
<li>按照应用协议交换报文<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>客户端进程：发起通信 的进程     服务器进程：等待连接 的进程</strong></p>
<p><strong>注意：P2P架构的应用也 有客户端进程和服务器进程之分</strong></p>
<h3 id="分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）"><a href="#分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）" class="headerlink" title="分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）"></a>分布式进程通信需要解决的问题（应用进程如何使用传输层提供的服务交换报文）</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722150538808.png" alt="image-20210722150538808"></p>
<p> 问题1：<strong>进程标示和寻址问题    (对于进程 谁发/谁收，对等层实体之间)</strong> </p>
<p> 问题2：<strong>传输层-应用层提供服务是如何     (上下层间)</strong></p>
<ul>
<li> 位置：层间界面的SAP （TCP/IP ：socket） </li>
<li> 形式：应用程序接口API （TCP/IP ：socket API） </li>
</ul>
<p> 问题3：<strong>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用 （本层间）</strong></p>
<p> 定义应用层协议：报文格式，解释，时序等 </p>
<p> 编制程序，使用OS提供的API ，调用网络基础设施提 供通信服务传报文，实现应用时序等；</p>
<h4 id="问题1：对进程进行编址（addressing）"><a href="#问题1：对进程进行编址（addressing）" class="headerlink" title="问题1：对进程进行编址（addressing）"></a>问题1：对进程进行编址（addressing）</h4><ul>
<li>进程为了接收报文，必须有一个标识<br>即: SAP(发送也需要标示)<ul>
<li><strong>主机:唯一的32位IP地址</strong><br>仅仅有IP地址不能够唯一标示一个进程;在一台端系统上有很多应用进程在运行</li>
<li><strong>所采用的传输层协议:TCP or UDP</strong></li>
<li><u><strong>端口号(Port Numbers)   用来区分不同的应用进程   </strong></u></li>
</ul>
</li>
<li>一些知名端口号的例子:<ul>
<li>HTTP: TCP 80    Mail: TCP 25    ftp: TCP 2</li>
</ul>
</li>
<li>一个进程:用IP+port标示端节点</li>
<li>本质上，一对主机进程之间的通信由2个端节点构成</li>
</ul>
<h4 id="问题2：传输层提供的服务-需要穿过层间的信息"><a href="#问题2：传输层提供的服务-需要穿过层间的信息" class="headerlink" title="问题2：传输层提供的服务-需要穿过层间的信息"></a>问题2：传输层提供的服务-需要穿过层间的信息</h4><p>层间接口必须要携带的信息</p>
<ul>
<li><strong>要传输的报文(对于本层来说:SDU)</strong>    (SDU——未经本层封装的)    （发的什么）</li>
<li><strong>谁传的:对方的应用进程的标示:IP+TCP(UDP)端口</strong> （谁发的）</li>
<li><strong>传给谁:对方的应用进程的标示:对方的IP+TCP(UDP)端口号</strong> （发给谁）</li>
</ul>
<p>传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段(UDP数据报)的封装</p>
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报:源IP,目标IP</li>
</ul>
<blockquote>
<ul>
<li>如果Socket API（原语）每次传输报文（穿过层间），都携带如此多的信息，太繁琐易错，不便于管理</li>
<li>用个代号标示通信的双方或者单方: socket </li>
<li>就像OS打开文件返回的句柄一样<br>对句柄的操作，就是对文件的操作</li>
</ul>
</blockquote>
<h4 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h4><p><strong>TCP socket:</strong></p>
<ul>
<li>TCP服务，两个进程之间的通信需要之前要建立连扫<br>两个进程通信会持续一段时间，通信关系稳定</li>
<li>可以用一个整数表示两个应用实体之间的通信关系<br>，本地标示</li>
<li>穿过层间接口的信息量最小</li>
<li>TCP socket: 源IP,源端口，目标IP，目标IP,目标</li>
</ul>
<p><strong>TCP socket 是一个整数（类似文件描述符）代表一个四元组（我的IP和端口号    对方的IP和端口号）</strong><br><strong>便于管理   使得穿过层间的信息量最小</strong><br><strong>是应用层和传输层的一个约定    本地会话的标识</strong></p>
<p><strong>对于使用面向连接服务(TCP）的应用而言，套接字是4元组的一个具有本地意义的标识</strong></p>
<ul>
<li>4元组: (源IP，源port，目标IP，目标port)</li>
<li>唯一的指定了一个会话（2个进程之间的会话关系)</li>
<li>应用使用这个标示，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都要指定这4元组</li>
<li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li>
<li>简单，便于管理</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722160941836.png" alt="image-20210722160941836"></p>
<p><strong>穿过层间接口的包括 ICI 和 SDU</strong></p>
<h4 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h4><p><strong>UDP socket：</strong></p>
<ul>
<li>UDP服务，两个进程之间的通信需要之前无需建立连接<br>每个报文都是独立传输的<br>前后报文可能给不同的分布式进程</li>
<li>因此，只能用一个整数表示本应用实体的标示<br>因为这个报文可能传给另外一个分布式进程·1○穿过层间接口的信息大小最小</li>
<li><strong>UDP socket:本IP,本端口</strong><ul>
<li><strong>==但是传输报文时:必须要提供对方IP，port==</strong></li>
<li><strong>接收报文时:传输层需要上传对方的IP，port</strong></li>
</ul>
</li>
</ul>
<p><strong>对于使用无连接服务(UDP）的应用而言，套接字是2元组的一个具有本地意义的标识</strong></p>
<ul>
<li>2元组: IP，port(源端指定)</li>
<li>UDP套接字指定了应用所在的一个端节点(endpoint&gt;</li>
<li>在发送数据报时，采用创建好的本地套接字(标示ID），就不必在发送每个报文中指明自己所采用的ip和port</li>
<li>但是在发送报文时，必须要指定对方的ip和udpport(另外一个段节点)</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722162951507.png" alt="image-20210722162951507"></p>
<p>套接字（Socket）</p>
<p><strong>进程<u>向套接字发送报文</u>或<u>从套接字接收报文</u></strong></p>
<p>套接字&lt;-&gt;门户</p>
<ul>
<li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的<br>门将报文交付给接受进程</li>
<li>接收进程从另外一端的门户收到报文（依赖于传输层设施)</li>
</ul>
<h4 id="问题3：如何使用传输层提供的服务实现应用"><a href="#问题3：如何使用传输层提供的服务实现应用" class="headerlink" title="问题3：如何使用传输层提供的服务实现应用"></a>问题3：如何使用传输层提供的服务实现应用</h4><ol>
<li>定义应用层协议：报文格式，解释，时序等 </li>
<li>编制程序，<strong>通过API调用网络基础设施提供通信服务</strong>传报文，解析报文，实现应用时序等</li>
</ol>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>定义了:运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换的报文类型:请求和应答报文</li>
<li>各种报文类型的<strong>语法</strong>:报文中的客个字段及其描述</li>
<li>字段的<strong>语义</strong>:即字段取值的含义进程何时、如何发送报文及对报文进行响应的<strong>规则</strong></li>
</ul>
<p>应用协议仅仅是应用的一个组成部分<br>Web应用:HTTP协议，web客户端，web服务器，HTML(超文本标记语言)</p>
<p>公开协议：  由RFC文档定义  允许互操作  如HTTP, SMTP<br>专用（私有）协议：  协议不公开  如：Skype</p>
<h3 id="应用需要传输层提供什么样的服务？"><a href="#应用需要传输层提供什么样的服务？" class="headerlink" title="应用需要传输层提供什么样的服务？"></a>应用需要传输层提供什么样的服务？</h3><p>如何描述传输层的服务？</p>
<blockquote>
<p>数据丢失率<br>有些应用则要求100%的可<br>靠数据传输（如文件)<br>有些应用(如音频)能容忍<br>一定比例以下的数据丢失</p>
<p>延迟<br>一些应用出于有效性考虑，对<br>数据传输有严格的时间限制<br> Internet电话、交互式游戏o延迟、延迟差</p>
<p>吞吐<br>一些应用(如多媒体）必须<br>需要最小限度的吞吐，从而使得应用能够有效运转一些应用能充分利用可供使<br>用的吞吐(弹性应用)</p>
<p>安全性<br>机密性完整性<br>可认证性（鉴别)</p>
</blockquote>
<h3 id="常见应用对传输服务的要求"><a href="#常见应用对传输服务的要求" class="headerlink" title="常见应用对传输服务的要求"></a>常见应用对传输服务的要求</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722164856593.png" alt="image-20210722164856593"></p>
<h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h3><p>实体：实行网络协议的软件模块或硬件模块（运行中的）</p>
<p>TCP服务:<br>可靠的传输服务<br>流量控制:发送方不会淹<br>没接受方<br>拥塞控制:当网络出现拥<br>塞时，能抑制发送方<br>不能提供的服务:时间保<br>证、最小吞吐保证和安全面向连接:要求在客户端<br>进程和服务器进程之间建立连接</p>
<p>UDP服务:<br>不可靠数据传输<br>不提供的服务:可靠,<br>流量控制、拥塞控制、时间、带宽保证、建立连接<br>Q:为什么要有UDP?</p>
<p><strong>UDP存在的必要性</strong></p>
<ul>
<li>能够区分不同的进程，而IP服务不能<ul>
<li>在IP提供的主机到主机端到端功能的基础上，区分了主机的<br>应用进程</li>
</ul>
</li>
<li>无需建立连接，省去了建立连接时间，适合事务性的应用</li>
<li>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代<br>价（检错重发〉</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送<br>的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h3 id="Internet应用及其应用层协议和传输协议"><a href="#Internet应用及其应用层协议和传输协议" class="headerlink" title="Internet应用及其应用层协议和传输协议"></a>Internet应用及其应用层协议和传输协议</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722165542697.png" alt="image-20210722165542697"></p>
<p><strong>安全TCP</strong></p>
<p>TCP &amp; UDP<br> 都没有加密  明文通过互联网传输 ，甚至密码 </p>
<p>SSL  提供安全性<br> 在TCP上面实现，提供加密的TCP连接  私密性  数据完整性  端到端的鉴别</p>
<p>SSL在应用层  应用采用SSL库，SSL 库使用TCP通信</p>
<p>SSL socket API  应用通过API将明文交 给socket，SSL将其加 密在互联网上传输  详见第8章</p>
<p>Https 跑在 SSL + TCP 上</p>
<h2 id="2-2-Web-and-HTTP"><a href="#2-2-Web-and-HTTP" class="headerlink" title="2.2 Web and HTTP"></a>2.2 Web and HTTP</h2><p>一些术语</p>
<ul>
<li><p>Web页:由一些对象组成</p>
</li>
<li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p>
</li>
<li><p>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接)</p>
</li>
<li><p>通过URL对每个对象进行引用<br>访问协议，用户名，口令字，端口等；</p>
</li>
<li><p>URL格式:</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722202411559.png" alt="image-20210722202411559"></p>
</li>
</ul>
<h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>HTTP: 超文本传输协议<br> Web的应用层协议<br> 客户/服务器模式<br>     客户: 请求、接收和显示 Web对象的浏览器<br>     服务器: 对请求进行响应， 发送对象的Web服务器<br> HTTP 1.0: RFC 1945<br> HTTP 1.1: RFC 206</p>
<p><strong>使用TCP:</strong></p>
<ul>
<li><strong>客户发起一个与服务器的</strong><br><strong>TCP连接(建立套接字)，端口号为80</strong></li>
<li><strong>服务器接受客户的TCP连接</strong></li>
<li><strong>在浏览器(HTTP客户端)</strong><br><strong>与Web服务器(HTTP服务器server)</strong><br><strong>交换HTTP报文(应用层协议报文)</strong></li>
<li><strong>TCP连接关闭</strong></li>
</ul>
<p>HTTP是无状态的  服务器并不维护关于客户的任何信息</p>
<blockquote>
<p>维护状态的协议很复杂！<br> 必须维护历史信息(状态)<br> 如果服务器/客户端死机，它们的状态信息可能不一致， 二者的信息必须是一致<br> 无状态的服务器能够支持更 多的客户端</p>
</blockquote>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><p>非持久HTTP  最多只有一个对象在 TCP连接上发送  下载多个对象需要多 个TCP连接  HTTP/1.0使用非持 久连接</p>
<p>持久HTTP  多个对象可以在一个 （在客户端和服务器 之间的）TCP连接上 传输  HTTP/1.1 默认使用 持久连接</p>
<p>非持久HTTP </p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722234055927.png" alt="image-20210722234055927"></p>
<p>响应时间模型</p>
<p>往返时间RTT（round-trip time）：一个小的分组从客 户端到服务器，在回到客户 端的时间（传输时间忽略） </p>
<p>响应时间：  一个RTT用来发起TCP连接  一个 RTT用来HTTP请求并 等待HTTP响应  文件传输时间<br>总共：2个RTT + 一个对象的传输时间</p>
<p>持久HTTP</p>
<p>非持久HTTP的缺点：<br> 每个对象要2个 RTT<br> 操作系统必须为每个TCP连接分 配资源<br> 但浏览器通常打开并行TCP连接 ，以获取引用对象 </p>
<p>持久HTTP<br> 服务器在发送响应后，仍保持 TCP连接<br> 在相同客户端和服务器之间的后 续请求和响应报文通过相同的连 接进行传送<br> 客户端在遇到一个引用对象的时 候，就可以尽快发送该对象的请求 </p>
<p><strong>非流水方式的持久HTTP：  客户端只能在收到前一个响应后 才能发出新的请求  每个引用对象花费一个RTT</strong> </p>
<p><strong>流水方式的持久HTTP：  HTTP/1.1的默认模式  客户端遇到一个引用对象就立即 产生一个请求  所有引用（小）对象只花费一个RTT是可能的</strong></p>
<h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p> 两种类型的HTTP报文：请求、响应<br> HTTP请求报文:</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722234518706.png" alt="image-20210722234518706"></p>
<p>HTTP请求报文：通用格式</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722234848572.png" alt="image-20210722234848572"></p>
<p>提交表单输入（向服务器提交信息）</p>
<p>Post方式：  网页通常包括表单输 入  包含在实体主体 (entity body )中的 输入被提交到服务器</p>
<p>URL方式：  方法：GET  输入通过请求行的 URL字段上载</p>
<p>例子<br>www. somesite.com/animalsearch?monkeys&amp;banana<br>http: //www. baidu.com/s?wd=xx+yy+zzz&amp;cl=3</p>
<p>参数：wd，cl     参数值：XX+YY+zzz，3</p>
<p>方法类型</p>
<p>HTTP/1.0<br> GET  POST<br> HEAD<br> 要求服务器在响应报文中 不包含请求对象 -&gt; 故障跟踪 </p>
<p>HTTP/1.1  GET, POST, HEAD<br> PUT  将实体主体中的文件上载 到URL字段规定的路径<br> DELETE  删除URL字段规定的文件</p>
<h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210722235747718.png" alt="image-20210722235747718"></p>
<p>HTTP响应状态码</p>
<p>位于服务器→客户端的响应报文中的首行一些状态码的例子:</p>
<p>200 OK</p>
<ul>
<li>请求成功，请求对象包含在响应报文的后续部分</li>
</ul>
<p>301 Moved Permanently</p>
<ul>
<li>请求的对象己经被永久转移了;新的URL在响应报文的Location:首部行中指定<br>客户端软件自动用新的URL去获取对象</li>
</ul>
<p>400 Bad Request</p>
<ul>
<li>一个通用的差错代码，表示该请求不能被服务器解读</li>
</ul>
<p>404 Not Found</p>
<ul>
<li>请求的文档在该服务上没有找到</li>
</ul>
<p>505 HTTP version Not supported</p>
<p>Trying out HTTP (client side) for yourself</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723004345632.png" alt="image-20210723004345632"></p>
<h3 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a>用户-服务器状态：cookies</h3><p><strong>大多数主要的门户网站使 用 cookies 4个组成部分：</strong> </p>
<p><strong>1) 在HTTP响应报文中有 一个cookie的首部行</strong> </p>
<p><strong>2)在HTTP请求报文含有 一个cookie的首部行</strong> </p>
<p><strong>3) 在用户端系统中保留有 一个cookie文件，由用户的浏览器管理</strong> </p>
<p><strong>4) 在Web站点有一个后 端数据库</strong></p>
<p>例子：<br> Susan总是用同一个PC使 用Internet Explore上网<br> 她第一次访问了一个使 用了Cookie的电子商务网站<br> 当最初的HTTP请求到达 服务器时，该Web站点 产生一个唯一的ID，并 以此作为索引在它的后 端数据库中产生一个项</p>
<p>Cookies: 维护状态</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723005216576.png" alt="image-20210723005216576"></p>
<p>Cookies能带来什么：  用户验证  购物车  推荐  用户状态 (Web e-mail)</p>
<p>如何维持状态：  协议端节点：在多个事务上 ，发送端和接收端维持状态  cookies: http报文携带状 态信息</p>
<p>Cookies与隐私：<br> Cookies允许站点知道许多关于 用户的信息<br> 可能将它知道的东西卖给第三方<br> 使用重定向和cookie的搜索引 擎还能知道用户更多的信息<br> 如通过某个用户在大量站点 上的行为，了解其个人浏览方式的大致模式<br> 广告公司从站点获得信息</p>
<h3 id="Web缓存-代理服务器"><a href="#Web缓存-代理服务器" class="headerlink" title="Web缓存 (代理服务器)"></a>Web缓存 (代理服务器)</h3><p>目标：不访问<strong><u>原始服务器</u></strong>，就满足客户的请求</p>
<p> 用户设置浏览器： 通 过缓存访问Web </p>
<p> 浏览器将所有的HTTP 请求发给缓存<br>     在缓存中的对象：缓存 直接返回对象<br>     如对象不在缓存，缓存 请求原始服务器，然后 再将对象返回给客户端</p>
<p> 缓存既是客户端又是服务器  通常缓存是由ISP安 装 (大学、公司、居 民区ISP)</p>
<p>为什么要使用Web缓存 ？<br><strong> 降低客户端的请求响应时间</strong><br><strong> 可以大大减少一个机构内 部网络与Internent接入 链路上的流量</strong><br><strong> 互联网大量采用了缓存： 可以使较弱的ICP也能够 有效提供内容</strong></p>
<p>缓存示例</p>
<p>假设  平均对象大小 = 100kb  机构内浏览器对原始服务器的 平均请求率为 = 15请求/s  平均到浏览器的速率：1.5Mbps  机构内部路由器到原始服务器 再返回到路由器的的延时 （ Internet 延时）= 2s  接入链路带宽：1.54Mbps 结果  LAN的流量强度 = 15%<br><strong> 接入链路上的流量强度 = 99%</strong><br> 总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 </p>
<p><strong>t (queue) = I/(1 - I) * L / R</strong><br><strong>I——流量强度        L/R——一个分组的传输时间            排队延迟非常大</strong></p>
<p>缓存示例：更快的接入链路</p>
<p>假设  平均对象大小 = 100kb  机构内浏览器对原始服务器的 平均请求率为 = 15请求/s  平均到浏览器的速率：1.5Mbps  机构内部路由器到原始服务器 再返回到路由器的的延时 （ Internet 延时）= 2s <strong> 接入链路带宽：1.54Mbps——&gt; 154Mbps</strong> 结果  LAN的流量强度 = 15%  接入链路上的流量强度 = 99%<br><strong> 总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s</strong><br> <strong>代价: 增加了接入链路带宽（非常昂贵！）</strong></p>
<p><strong>排队延迟降低</strong></p>
<h3 id="缓存例子：安装本地缓存"><a href="#缓存例子：安装本地缓存" class="headerlink" title="缓存例子：安装本地缓存"></a>缓存例子：安装本地缓存</h3><p>假设  平均对象大小 = 100kb  机构内浏览器对原始服务器的平均 请求率为 = 15请求/s  平均到浏览器的速率：1.5Mbps <strong> 机构内部路由器到原始服务器再返回到路由器的的延时 （Internet 延 时）= 2s</strong>  接入链路带宽：1.54Mbps 结果 LAN 利用率: 15%  接入网络利用率： ？  总体延迟= ? ? How to compute link utilization, delay? <strong>代价: web缓存(廉价!)</strong></p>
<p>计算链路利用率，有缓存的延迟： 假设缓存命中率0.4  40%请求在缓存中被满足，其他60%的请求 需要被原始服务器满足  接入链路利用率:  60%的请求采用接入链路  进过接入链路到达浏览器的数据速 率 = 0.6<em>1.50 Mbps = .9 Mbps  利用率= 0.9/1.54 = .58  总体延迟：  = 0.6 </em> (从原始服务器获取对象的 延迟) +0.4 <em> (从缓存获取对象的延迟)<br><em>* = 0.6 (2.01) + 0.4 (msecs)  =  1.2 secs  比安装154Mbps链路还来得小 (而且 比较便宜!)</em></em></p>
<p><strong>条件GET方法（对象版本和服务器版本一致性问题）</strong></p>
<p> 目标：如果缓存器中的对 象拷贝是最新的，就不要发送对象<br> 缓存器: 在HTTP请求中指 定缓存拷贝的日期 If-modified-since:  \<date><br> 服务器: 如果缓存拷贝陈 旧，则响应报文没包含对象: HTTP/1.0 304 Not Modified</p>
<h2 id="2-3-FTP"><a href="#2-3-FTP" class="headerlink" title="2.3 FTP*"></a>2.3 FTP*</h2><p>FTP: 文件传输协议</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723081249382.png" alt="image-20210723081249382"></p>
<p> 向远程主机上传输文件或从远程主机接收文件<br> 客户/服务器模式<br>         客户端：发起传输的一方<br>         服务器：远程主机<br> ftp: RFC 959<br> ftp服务器：端口号为21</p>
<h3 id="FTP-控制连接与数据连接分开"><a href="#FTP-控制连接与数据连接分开" class="headerlink" title="FTP: 控制连接与数据连接分开"></a>FTP: 控制连接与数据连接分开</h3><p> FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议<br> 客户端通过控制连接获得身份确认<br> 客户端通过控制连接发送命令浏览远程目录<br> 收到一个文件传输命令时，服务器打开一个到客户端的数据连接<br> 一个文件传输完成后，服务器关闭连接</p>
<p><strong> 服务器打开 <u>第二个TCP</u> 数据连接用来传输另一个文件（服务器主动）</strong><br><strong> 控制连接： 带外（ “out of band” ）传送</strong><br><strong> FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应</strong><br><strong>有状态的协议</strong></p>
<h3 id="FTP命令、响应"><a href="#FTP命令、响应" class="headerlink" title="FTP命令、响应"></a>FTP命令、响应</h3><p>命令样例：<br> 在控制连接上以ASCII文本方式传送<br> USER username<br> PASS password<br> LIST：请服务器返回远程主 机当前目录的文件列表<br> RETR filename：从远程主 机的当前目录检索文件 (gets)<br> STOR filename：向远程主 机的当前目录存放文件 (puts)<br>返回码样例：<br> 状态码和状态信息 (同HTTP)<br> 331 Username OK, password required<br> 125 data connection already open; transfer starting<br> 425 Can’t open data connection  452 Error writing file</p>
<h3 id="FTP协议与HTTP协议的差别"><a href="#FTP协议与HTTP协议的差别" class="headerlink" title="FTP协议与HTTP协议的差别"></a>FTP协议与HTTP协议的差别</h3><p><strong>FTP协议是有状态的，FTP协议的控制命令和数据传输分别在两个TCP上进行</strong></p>
<h2 id="2-4-EMail"><a href="#2-4-EMail" class="headerlink" title="2.4 EMail"></a>2.4 EMail</h2><p>3个主要组成部分：  用户代理  邮件服务器  简单邮件传输协议：SMTP </p>
<p>用户代理 （客户端软件）<br> 又名 “邮件阅读器”<br> 撰写、编辑和阅读邮件<br> 如Outlook、Foxmail<br> 输出和输入邮件保存在服务器 上</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723084335560.png" alt="image-20210723084335560"></p>
<p>邮件服务器<br> 邮箱中管理和维护发送给用户的邮件<br> 输出报文队列保持待发送邮件报文<br> 邮件服务器之间的SMTP协议 ：发送email报文<br>     客户：发送方邮件服务器<br>     服务器：接收端邮件服务器</p>
<h3 id="EMail-SMTP-RFC-2821-原理"><a href="#EMail-SMTP-RFC-2821-原理" class="headerlink" title="EMail: SMTP [RFC 2821] 原理"></a>EMail: SMTP [RFC 2821] 原理</h3><p> 使用TCP在客户端和服务器之间传送报文，端口号为25<br> 直接传输：从发送方服务器到接收方服务器<br> 传输的3个阶段 握手 传输报文 关闭<br> 命令/响应交互<br>        命令：ASCII文本<br>        响应：状态码和状态信息<br> 报文必须为7位ASCII码 （规范传输内容）</p>
<p>举例：Alice给Bob发送报文</p>
<p>1) Alice使用用户代理撰写邮件并发送给 bob@someschool.edu<br><strong>2) Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中</strong><br>3) SMTP的客户端打开到Bob邮件服务器的TCP连接<br><strong>4) SMTP客户端通过TCP连接发送Alice的邮件</strong><br><strong>5) Bob的邮件服务器将邮件放到Bob的邮箱</strong><br>6) Bob调用他的用户代理阅读邮件</p>
<h3 id="简单的SMTP交互"><a href="#简单的SMTP交互" class="headerlink" title="简单的SMTP交互"></a>简单的SMTP交互</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723090653643.png" alt="image-20210723090653643"></p>
<h3 id="SMTP：总结"><a href="#SMTP：总结" class="headerlink" title="SMTP：总结"></a>SMTP：总结</h3><p> <strong>SMTP使用持久连接</strong><br><strong> SMTP要求报文（首部 和主体）为7位ASCII编 码</strong><br> <strong>SMTP服务器使用 CRLF.CRLF决定报文的 尾部</strong></p>
<p>HTTP比较：<br> HTTP：拉（pull）<br> SMTP：推（push）<br> 二者都是ASCII形式的命令/ 响应交互、状态码<br> HTTP：<strong>每个对象封装在各自的响应报文中</strong><br> SMTP：<strong>多个对象包含在一个报文中</strong></p>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>SMTP：交换email报文的协议 RFC 822: 文本报文的标准：<br> 首部行：如,<br>         To:  From:  Subject:<br> 主体<br>         报文，只能是ASCII码字符</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723091532349.png" alt="image-20210723091532349"></p>
<p>报文格式：多媒体扩展</p>
<p> MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056<br> 在报文首部用额外的行申明MIME内容类型</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904197519835150">常用Base64 对STMP的ASCII码进行拓展 传输更多内容</a></p>
<blockquote>
<p>Base64 常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。<strong>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。</strong>使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号  = 用来作为后缀用途。</p>
</blockquote>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723091948545.png" alt="image-20210723091948545"></p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723101026569.png" alt="image-20210723101026569"></p>
<p>两推一拉</p>
<p> SMTP: 传送到接收方的邮件服务器<br> 邮件访问协议：从服务器访问邮件 （3种方式）</p>
<ol>
<li><p>POP3：邮局访问协议（Post Office Protocol）[RFC 1939] </p>
<pre><code>     用户身份确认 (代理&lt;--&gt;服务器) 并下载     
</code></pre></li>
<li><p>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730] </p>
<pre><code>     更多特性和功能 (更复杂) 
        在服务器上处理存储的报文 
</code></pre></li>
<li><p>HTTP：Hotmail , Yahoo! Mail等 </p>
<pre><code>     方便
</code></pre></li>
</ol>
<h3 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h3><p>用户确认阶段  客户端命令：  user: 申明用户名  pass: 口令  服务器响应  +OK  -ERR<br>事物处理阶段   客户端：  list: 报文号列表  retr: 根据报文号检索报文  dele: 删除  quit</p>
<p>用户确认阶段</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723101430314.png" alt="image-20210723101430314"></p>
<p>事物处理阶段,</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723101438747.png" alt="image-20210723101438747"></p>
<p>POP3<br> 先前的例子使用 “下载 并删除”模式。<br> 如果改变客户机，Bob不 能阅读邮件<br> “下载并保留”：不同 客户机上为报文的拷贝<br> POP3在会话中是无状态的 </p>
<h3 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a><strong>IMAP</strong></h3><p> IMAP服务器将每个报文 与一个文件夹联系起来<br> 允许用户用目录来组织 报文<br> 允许用户读取报文组件<br> IMAP在会话过程中保留 用户状态：<br> 目录名、报文ID与目录名 之间映射</p>
<h2 id="2-5-DNS"><a href="#2-5-DNS" class="headerlink" title="2.5 DNS"></a>2.5 DNS</h2><p>DNS(Domain Name System)</p>
<p>从域名到IP地址的转换（主要功能）</p>
<h3 id="DNS的必要性"><a href="#DNS的必要性" class="headerlink" title="DNS的必要性"></a>DNS的必要性</h3><p>​     IP地址标识主机、路由器<br>​     <strong>但IP地址不好记忆，不便人类使用(没有意义)</strong><br>​     <strong>人类一般倾向于使用一些有意义的字符串来标识 Internet上的设备</strong><br>​    <strong>例如：qzheng@ustc.edu.cn</strong><br>​    <strong>所在的邮件服务器 www.ustc.edu.cn 所在的web服务器</strong> </p>
<p>​     存在着“字符串”—IP地址的转换的必要性<br>​     人类用户提供要访问机器的“字符串”名称<br>​     由DNS负责转换成为二进制的网络地址</p>
<p>DNS系统需要解决的问题</p>
<p> 问题1：如何命名设备<br>     用有意义的字符串：好记，便于人类用使用<br>     解决一个平面命名的重名问题：层次化命名<br> 问题2：如何完成名字到IP地址的转换<br>     分布式的数据库维护和响应名字查询<br> 问题3：如何维护：增加或者删除一个域，需 要在域名系统中做哪些工作</p>
<p>DNS(Domain Name System)的历史</p>
<p> ARPANET的名字解析解决方案<br>     主机名：没有层次的一个字符串（一个平面）<br>     存在着一个（集中）维护站：维护着一张 主机名-IP地址 的映射文件：Hosts.txt<br>     每台主机定时从维护站取文件<br> ARPANET解决方案的问题  当网络中主机数量很大时  没有层次的主机名称很难分配 </p>
<h3 id="DNS-Domain-Name-System-总体思路和目标"><a href="#DNS-Domain-Name-System-总体思路和目标" class="headerlink" title="DNS(Domain Name System)总体思路和目标"></a>DNS(Domain Name System)总体思路和目标</h3><p> DNS的主要思路<br>     <strong>分层的、基于域的命名机制</strong><br>     <strong>若干分布式的数据库完成名字到IP地址的转换</strong><br>     <strong>运行在UDP之上端口号为53的应用服务</strong><br>     核心的Internet功能，但以应用层协议实现<br>         <strong>在网络边缘处理复杂性 （互联网最核心的功能（DNS）在边缘系统实现的）</strong></p>
<p> DNS主要目的：<br>     实现主机名-IP地址的转换(name/IP translate) （主要功能）<br>     其它目的<br>         <strong>主机别名到  <u>规范名字</u>  的转换：Host aliasing</strong><br>         <strong>邮件服务器别名到邮件服务器的  <u>正规名字</u>  的转换：Mail server aliasing</strong><br>         <strong>负载均衡：Load Distribution（分配具体的服务器提供服务）</strong></p>
<h3 id="问题1：DNS名字空间-The-DNS-Name-Space"><a href="#问题1：DNS名字空间-The-DNS-Name-Space" class="headerlink" title="问题1：DNS名字空间(The DNS Name Space)"></a>问题1：DNS名字空间(The DNS Name Space)</h3><p> DNS域名结构<br>     一个层面命名设备会有很多重名<br>     NDS采用层次树状结构的 命名方法<br>     <strong>Internet 根被划为几百个顶级域(top lever domains)</strong><br>        通用的(generic) .com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ; .web ; .arts ; .rec ;<br>        <strong>国家的(countries) .cn ; .us ; .nl ; .jp</strong><br>     每个(子)域下面可划分为若干子域(subdomains)<br>     树叶是主机</p>
<h4 id="DNS-根名字服务器"><a href="#DNS-根名字服务器" class="headerlink" title="DNS: 根名字服务器"></a>DNS: 根名字服务器</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723160541606.png" alt="image-20210723160541606"></p>
<p>DNS名字空间(The DNS Name Space)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723161151756.png" alt="image-20210723161151756"></p>
<p>域名(Domain Name)<br>    <strong>从本域往上，直到树根</strong><br>    <strong>中间使用“.”间隔不同的级别</strong><br>    例如：ustc.edu.cn<br>             auto.ustc.edu.cn<br>             www.auto. ustc.edu.cn<br>    域的域名：可以用于表示一个域<br>    主机的域名：一个域上的一个主机</p>
<p> 域名的管理<br>     一个域管理其下的子域<br>        .jp 被划分为 ac.jp co.jp<br>        .cn 被划分为 edu.cn com.cn<br>     <strong>创建一个新的域，必须征得它所属域的同意</strong><br> <strong>域与物理网络无关</strong><br>     <strong>域遵从组织界限，而不是物理网络</strong><br>         一个域的主机可以不在一个网络<br>         一个网络的主机不一定在一个域<br>     <strong>域的划分是逻辑的，而不是物理的</strong></p>
<h3 id="问题2：解析问题-名字服务器-Name-Server"><a href="#问题2：解析问题-名字服务器-Name-Server" class="headerlink" title="问题2：解析问题-名字服务器(Name Server)"></a>问题2：解析问题-名字服务器(Name Server)</h3><p> <strong>一个名字服务器的问题</strong><br>     <strong>可靠性问题：单点故障</strong><br>     <strong>扩展性问题：通信容量</strong><br>     <strong>维护问题：远距离的集中式数据库</strong> </p>
<p> <strong>区域(zone)</strong><br>     区域的划分有区域管理者自己决定<br>     将DNS名字空间划分为互不相交的区域，每个区域都是 树的一部分<br>     名字服务器：<br>         每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record)<br>         名字服务器允许被放置在区域之外，以保障可靠性</p>
<h4 id="名字空间划分为若干区域：Zone"><a href="#名字空间划分为若干区域：Zone" class="headerlink" title="名字空间划分为若干区域：Zone"></a>名字空间划分为若干区域：Zone</h4><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723163720694.png" alt="image-20210723163720694"></p>
<p><strong>权威DNS服务器：组织机构的DNS服务器， 提供组织机构服务器（如 Web和mail）可访问的主机和IP之间的映射</strong><br>组织机构可以选择实现自己维护或由某个服务提供商来维护</p>
<h4 id="TLD服务器"><a href="#TLD服务器" class="headerlink" title="TLD服务器"></a>TLD服务器</h4><p> 顶级域(TLD)服务器：负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp ）<br>     Network solutions 公司维护com TLD服务器<br>     Educause公司维护edu TLD服务器</p>
<h4 id="区域名字服务器维护资源记录"><a href="#区域名字服务器维护资源记录" class="headerlink" title="区域名字服务器维护资源记录"></a>区域名字服务器维护资源记录</h4><p>资源记录(resource records)<br>    作用：维护 域名-IP地址(其它)的映射关系<br>    位置：Name Server的分布式数据库中<br> RR格式: (domain_name, ttl, type,class,Value)<br>    Domain_name: 域名<br>    <strong>Ttl: time to live : 生存时间(权威记录，缓冲记录)</strong>             <strong>缓冲是为了性能    删除是为了一致性</strong><br>    Class 类别 ：对于Internet，值为IN                                     <strong>说明是Internet网</strong><br>    Value 值：可以是数字，域名或ASCII串                                <strong>对应的IP地址</strong><br>    Type 类别：资源记录的类型—见下页</p>
<p>DNS记录</p>
<p>DNS ：保存资源记录(RR)的分布式数据库<br>RR 格式：(name, value, type, ttl)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723165002924.png" alt="image-20210723165002924"></p>
<p>信息1 （叫什么）<br><strong>TYPE = NS  Name放的是子域的名字<br>Value  子域名字服务器（权威DNS服务器）的名字</strong>    </p>
<p>信息2 （在哪）<br><strong>Type = A    Name放的是名字（子域的名字）</strong><br><strong>Value 对应服务器的IP地址</strong></p>
<h3 id="DNS大致工作过程"><a href="#DNS大致工作过程" class="headerlink" title="DNS大致工作过程"></a>DNS大致工作过程</h3><p><strong>一台设备上网必备的IP信息</strong><br><strong>我的IP地址        我的子网掩码        我的local name serve        我的default getway（路由器）</strong></p>
<p>​    应用调用 解析器(resolver)<br>​    解析器作为客户 向Name Server发出查询报文 （封装在UDP段中）<br>​    Name Server返回响应报文(name/ip)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723165920149.png" alt="image-20210723165920149"></p>
<h4 id="本地名字服务器（Local-Name-Server）"><a href="#本地名字服务器（Local-Name-Server）" class="headerlink" title="本地名字服务器（Local Name Server）"></a>本地名字服务器（Local Name Server）</h4><p> 并不严格属于层次结构<br> 每个ISP (居民区的ISP、公司、大学）都有一 个本地DNS服务器<br>     也称为“默认名字服务器”<br> 当一个主机发起一个DNS查询时，查询被送到 其本地DNS服务器<br>     起着代理的作用，将查询转发到层次结构中</p>
<h4 id="名字服务器-Name-Server"><a href="#名字服务器-Name-Server" class="headerlink" title="名字服务器(Name Server)"></a>名字服务器(Name Server)</h4><p>名字解析过程<br>    目标名字在Local Name Server中<br>        情况1：查询的名字在该区域内部<br>        情况2：缓存(cashing)</p>
<p>当与本地名字服务器不能解析名字时，联系根名字服务器 顺着根-TLD 一直找到 权威名字服务器</p>
<p>递归查询<br> <strong>名字解析负担都 放在当前联络的 名字服务器上</strong><br> 问题：根服务器 的负担太重<br> 解决： 迭代查询 (iterated queries)</p>
<p>迭代查询</p>
<p> 主机cis.poly.edu 想知道主机 gaia.cs.umass.edu 的IP地址<br> <strong>根（及各级域名）服务器返回的不是查询结果，而 是下一个NS的地址</strong><br> <strong>最后由权威名字服务器给出解析结果</strong><br> 当前联络的服务器给出可以联系的服务器的名字<br> “我不知道这个名字，但可以向这个服务器请求</p>
<h3 id="DNS协议、报文"><a href="#DNS协议、报文" class="headerlink" title="DNS协议、报文"></a>DNS协议、报文</h3><p>DNS协议：查询和响应报文的报文格式相同</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723171209907.png" alt="image-20210723171209907"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723171404280.png" alt="image-20210723171404280"></p>
<p>提高性能：缓存</p>
<p> 一旦名字服务器学到了一个映射，就将该映射 缓存起来<br> 根服务器通常都在本地服务器中缓存着<br>     使得根服务器不用经常被访问<br> 目的：提高效率<br> 可能存在的问题：如果情况变化，缓存结果和 权威资源记录不一致<br> 解决方案：TTL（默认2天）</p>
<h3 id="问题3：维护问题：新增一个域"><a href="#问题3：维护问题：新增一个域" class="headerlink" title="问题3：维护问题：新增一个域"></a>问题3：维护问题：新增一个域</h3><ul>
<li><strong>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</strong><br>（Type = NS、 Type = A  相当于指针）</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域<br>的名字解析:名字-&gt;IP地址<br>例子:在com域中建立一个“Network Utopia”</li>
<li>到注册登记机构注册域名networkutopia.com<ul>
<li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字<br>和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录:<br>( networkutopia.com,dns1.networkutopia.com,NS )( dns1.networkutopia.com,212.212.212.1,A)</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有<ul>
<li>用于Web服务器的www.networkuptopia.com的类型为A的记录</li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
<p>攻击DNS        总的说来，DNS比较健壮</p>
<p>DDoS 攻击<br> 对根服务器进行流量轰炸 攻击：发送大量ping<br> 没有成功<br> 原因１：根目录服务器配置 了流量过滤器，防火墙<br> 原因２：Local DNS 服务器 缓存了TLD服务器的IP地址, 因此无需查询根服务器 </p>
<p> 向TLD服务器流量轰炸攻击 ：发送大量查询<br> 可能更危险<br> 效果一般，大部分DNS缓存 了TLD</p>
<p>重定向攻击<br> 中间人攻击  截获查询，伪造回答，从而攻击 某个（DNS回答指定的IP）站点<br> DNS中毒  发送伪造的应答给DNS服务器，希 望它能够缓存这个虚假的结果<br> 技术上较困难：分布式截获和伪造 利用DNS基础设施进行DDoS<br> 伪造某个IP进行查询， 攻击这个 目标IP<br> 查询放大，响应报文比查询报文大<br> 效果有限</p>
<p>流量是分布式        查询有几乎都有缓存，基本不需要根  ——&gt;    无根也基本安全</p>
<h2 id="2-6-P2P-应用"><a href="#2-6-P2P-应用" class="headerlink" title="2.6 P2P 应用"></a>2.6 P2P 应用</h2><p> 没有（或极少）一直运行的 服务器<br> 任意端系统都可以直接通信<br> 利用peer的服务能力<br> Peer节点间歇上网，每次IP 地址都有可能变化<br>例子:<br>     文件分发 (BitTorrent)<br>     流媒体(KanKan)<br>     VoIP (Skype) </p>
<h3 id="文件分发-C-S-vs-P2P"><a href="#文件分发-C-S-vs-P2P" class="headerlink" title="文件分发: C/S vs P2P"></a>文件分发: C/S vs P2P</h3><p>问题: 从一台服务器分发文件（大小F）到N个peer 需要多少时间？</p>
<p>文件分发时间: C/S模式</p>
<p> 服务器传输： 都是由服务器 发送给peer，服务器必须顺序 传输（上载）N个文件拷贝: </p>
<ul>
<li><strong>发送一个copy: F/us（上载）</strong> </li>
<li><strong>发送N个copy： NF/us （上载）</strong></li>
</ul>
<p>客户端: 每个客户端必须下 载一个文件拷贝 </p>
<ul>
<li>dmin = 客户端最小的下载速率 </li>
<li><strong>下载带宽最小的客户端下载的 时间：F/dmin  （下载）</strong></li>
</ul>
<p><u><strong>采用C-S方法 将一个F大小的文件 分发给N个客户端耗时 Dc-s &gt; max{NF/us（随着N线性增长 ）,F/dmin}</strong></u><br><u><strong>(瓶颈却决于服务器的性能和客户端性能的相对强弱)</strong></u></p>
<p>文件分发时间: P2P模式</p>
<p> 服务器传输：最少需要<strong>上载</strong>一份 拷贝</p>
<ul>
<li><strong>发送一个拷贝的时间：F/us （上载）</strong></li>
</ul>
<p>客户端: 每个客户端必须<strong>下载</strong>一 个拷贝 </p>
<ul>
<li><strong>最小下载带宽客户单耗时: F/dmin（下载）</strong> </li>
</ul>
<p>客户端: 所有客户端总体下载量NF </p>
<ul>
<li><strong>最大上载带宽是：us（服务器的） + Sui（所有客户端的）  （上载）</strong> </li>
<li><strong><u>除了服务器可以上载，其他所有的peer节点都可以上载</u></strong></li>
</ul>
<p><u><strong>采用P2P方法 将一个F大小的文件 分发给N个客户端耗时 Dp2p &gt; max{F/us,F/dmin,NF/(us + Sui)}</strong></u> </p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723173824123.png" alt="image-20210723173824123"></p>
<p>C-S 线性<br>P2P 非线性    性能高    可拓展性强            难管理（动态性强）</p>
<p>非结构化P2P    任意连接<br>DHT 结构化P2P    如：环形、树        <strong>节点哈希    内容哈希    按一定规律存内容</strong></p>
<h3 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a>P2P文件共享</h3><p>例子<br> Alice在其笔记本电脑上 运行P2P客户端程序  间歇性地连接到 Internet，每次从其 ISP得到新的IP地址  请求“双截棍.MP3”  应用程序显示其他有“ 双截棍.MP3” 拷贝的对 等方</p>
<p> Alice选择其中一个对等方， 如Bob.  文件从Bob’s PC传送到 Alice的笔记本上：HTTP  当Alice下载时，其他用户也 可以从Alice处下载  Alice的对等方既是一个Web 客户端，也是一个瞬时Web 服务器</p>
<p>所有的对等方都是服务器 = 可扩展性好！</p>
<h4 id="两大问题"><a href="#两大问题" class="headerlink" title="两大问题"></a>两大问题</h4><p>​    如何定位所需资源<br>​    如何处理对等方的 加入与离开 </p>
<p>可能的方案<br>    集中<br>    分散<br>    半分散</p>
<h3 id="1、集中式目录"><a href="#1、集中式目录" class="headerlink" title="1、集中式目录"></a>1、集中式目录</h3><p>最初的“Napster”设计<br>1) 当对等方连接时，它告知<br>    中心服务器：  IP地址  内容<br>2) Alice查询 “双截棍 .MP3”<br>3) Alice从Bob处请求文件</p>
<p><u><strong> 单点故障  性能瓶颈  侵犯版权</strong></u><br>文件传输是分散的， 而定位内容则是高度集中的</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723205655842.png" alt="image-20210723205655842"></p>
<h3 id="2、查询洪泛：Gnutella（完全分布式）"><a href="#2、查询洪泛：Gnutella（完全分布式）" class="headerlink" title="2、查询洪泛：Gnutella（完全分布式）"></a>2、查询洪泛：Gnutella（完全分布式）</h3><p> <strong>全分布式</strong><br>     <strong>没有中心服务器</strong><br> 开放文件共享协议<br> <strong>许多Gnutella客户端 实现了Gnutella协议</strong><br>     类似HTTP有许多的 浏览器</p>
<p>覆盖网络：图<br> <strong>如果X和Y之间有一个 TCP连接，则二者之间存在一条边</strong><br> <strong>所有活动的对等方和边就是覆盖网络</strong><br> 边并不是物理链路<br> 给定一个对等方，通常 所连接的节点少于10个</p>
<blockquote>
<p> 在已有的TCP连接上发送查询报文<br> 对等方转发查询报文<br> <strong>以反方向返回查询命中报文</strong></p>
</blockquote>
<h4 id="泛洪查询-flooding"><a href="#泛洪查询-flooding" class="headerlink" title="泛洪查询 flooding"></a>泛洪查询 flooding</h4><p>我的客户端向所有邻居发出查询        所有邻居的客户端向其邻居发出查询 …<br>拥有资源的节点通过反向的方法将查询的结果发回来</p>
<p><strong><u>我的客户端就知道那个节点有资源——解决目录的问题——再向拥有资源的节点发出请求，得到资源</u></strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723210354195.png" alt="image-20210723210354195"></p>
<p>Gnutella：对等方加入（网络的建立）</p>
<ol>
<li>对等方X必须首先发现某些已经在覆盖网络中的其他对 等方：使用可用对等方列表 <strong><u> 自己维持一张对等方列表（经常开机的对等方的IP、死党列表）</u></strong> 联系维持列表的Gnutella站点 </li>
<li>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接 </li>
<li>X向Y发送一个Ping报文，Y转发该Ping报文 </li>
<li><strong>所有收到Ping报文的对等方以Pong报文响应 IP地址、共享文件的数量及总字节数</strong> </li>
<li><strong>X收到许多Pong报文，然后它能建立其他TCP连接</strong></li>
</ol>
<h3 id="3、利用不匀称性：KaZaA（混合体）"><a href="#3、利用不匀称性：KaZaA（混合体）" class="headerlink" title="3、利用不匀称性：KaZaA（混合体）"></a>3、利用不匀称性：KaZaA（混合体）</h3><p><strong>每个对等方要么是一个组长，要么隶属于一个组长</strong> </p>
<ul>
<li>对等方与其组长之间有 TCP连接 </li>
<li>组长对之间有TCP连接 </li>
</ul>
<p>组长跟踪其所有的孩子的内容 </p>
<p>组长与其他组长联系 </p>
<ul>
<li>转发查询到其他组长 </li>
<li>获得其他组长的数据拷贝</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723211651908.png" alt="image-20210723211651908"></p>
<h4 id="KaZaA：查询"><a href="#KaZaA：查询" class="headerlink" title="KaZaA：查询"></a>KaZaA：查询</h4><p> <u><strong>每个文件有一个散列标识码（唯一Hash，上载时赋予）和一个描述符</strong></u><br> 客户端向其组长发送关键字查询<br> 组长用匹配（描述）进行响应：<br>     对每个匹配：元数据、散列标识码和IP地址<br> 如果组长将查询转发给其他组长，其他组长也 以匹配进行响应<br> 客户端选择要下载的文件<br>     向拥有文件的对等方发送一个带散列标识码的 HTTP请求</p>
<h4 id="Kazaa小技巧"><a href="#Kazaa小技巧" class="headerlink" title="Kazaa小技巧"></a>Kazaa小技巧</h4><p>请求排队 </p>
<ul>
<li>限制并行上载的数量 </li>
<li>确保每个被传输的文件从上载节点接收一定量的带宽 </li>
</ul>
<p>激励优先权 </p>
<ul>
<li>鼓励用户上载文件 </li>
<li>加强系统的扩展性 </li>
</ul>
<p>并行下载 </p>
<ul>
<li>从多个对等方下载同一个文件的不同部分 <ul>
<li>HTTP的字节范围首部 </li>
<li>更快地检索一个文件</li>
</ul>
</li>
</ul>
<h4 id="Distributed-Hash-Table-DHT"><a href="#Distributed-Hash-Table-DHT" class="headerlink" title="Distributed Hash Table (DHT)"></a>Distributed Hash Table (DHT)</h4><p><u><strong> 哈希表  DHT方案  环形DHT 以及覆盖网络  Peer波动</strong></u></p>
<h3 id="（实际的例子）P2P文件分发：-BitTorrent"><a href="#（实际的例子）P2P文件分发：-BitTorrent" class="headerlink" title="（实际的例子）P2P文件分发： BitTorrent"></a>（实际的例子）P2P文件分发： BitTorrent</h3><p> <strong>文件被分为一个个块256KB</strong><br><u><strong>每个节点有一个bit map（hash），用map标记是否具备，有则标识为1否则为0</strong></u><br> <strong>网络中的这些peers发送接收文件块，相互服务</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210723203007411.png" alt="image-20210723203007411"></p>
<p> Peer加入torrent:<br>     <strong>一开始没有块（吸血鬼），但是将会通 过其他节点处累积文件块</strong><br>     向跟踪服务器注册，获得 peer节点列表，和部分peer 节点构成邻居关系 (“连接 ”)<br> <strong>当peer下载时，该peer可以同时向其他节点提供上载服务</strong><br> Peer可能会变换用于交换块的peer节点<br> <strong>扰动churn: peer节点可能会上线或者下线</strong><br> <strong>一旦一个peer拥有整个文件（种子）</strong>，它会（自私的）离开或者保留（利他主义）在torrent中</p>
<h4 id="BitTorrent-请求，发送文件块"><a href="#BitTorrent-请求，发送文件块" class="headerlink" title="BitTorrent: 请求，发送文件块"></a>BitTorrent: 请求，发送文件块</h4><p>请求块：<br> 在任何给定时间，不同 peer节点拥有一个文件块 的子集<br> 周期性的，Alice节点向 邻居询问他们拥有哪些块 的信息<br> <strong>Alice向peer节点请求它 <u>希望的块，稀缺的块</u>（稀缺优先，对集体有利）</strong></p>
<p><strong>1、（集体提出）客户端优先请求稀缺的（稀缺优先，对集体有利）</strong><br><strong>2、（集体定的规则）优先向提供服务好的客户端服务（个人利益与集体利益绑定）</strong><br><strong>3、（造成个人遵守）客户端优先请求稀缺的 （利他等于利己）</strong></p>
<p>发送块：一报还一报titfor-tat<br> <strong>Alice向<u>4个peer</u>发送块，这些块向它自己提供最大带宽的服务</strong><br> 其他peer被Alice阻塞 (将不会 从Alice处获得服务)<br> <strong>每10秒重新评估（谁对它好）一次：前4位</strong><br> <strong>每个30秒：随机选择其他peer 节点，向这个节点发送块</strong><br> “优化疏通” 这个节点<br> <strong>新选择的节点可以加入这个top 4</strong></p>
<p>(1) Alice “优化疏通” Bob<br>(2) Alice 变成了Bob的前4位提供者; Bob答谢Alice<br>(3) Bob 变成了Alice的前4提供者</p>
<p><strong>更高的上载速率： 发现更好的交易伙伴，获得更快的文件传输速率!</strong></p>
<h2 id="2-7-CDN"><a href="#2-7-CDN" class="headerlink" title="2.7 CDN"></a>2.7 CDN</h2><p>视频流化服务和CDN：上下文 </p>
<ul>
<li>视频流量：占据着互联网大部分的带宽<ul>
<li>Netflix, YouTube: 占据37%, 16% 的ISP下行流 量</li>
<li>~1B YouTube 用户, ~75M Netflix用户 </li>
</ul>
</li>
<li>挑战：规模性-如何服务者 ~1B 用户? <ul>
<li>单个超级服务器无法提供服务（为什么） </li>
</ul>
</li>
<li>挑战：异构性 <ul>
<li>不同用户拥有不同的能力（例如：有线接入和移 动用户；带宽丰富和受限用户） </li>
</ul>
</li>
<li><strong>解决方案: 分布式的，应用层面的基础设施</strong></li>
</ul>
<blockquote>
<p>多媒体: 视频</p>
<p>视频：固定速度显示的图像序 列</p>
<ul>
<li>e.g. 24 images/sec </li>
</ul>
<p>网络视频特点： </p>
<ul>
<li>高码率：&gt;10x于音频,高的网络带 宽需求 </li>
<li>可以被压缩 </li>
<li>90%以上的网络流量是视频 </li>
</ul>
<p>数字化图像：像素的阵列 </p>
<ul>
<li>每个像素被若干bits表示 </li>
</ul>
<p>编码：使用图像内和图像间的 冗余来降低编码的比特数 </p>
<ul>
<li>空间冗余(图像内) </li>
<li>时间冗余(相邻的图像间)</li>
</ul>
<p>CBR: (constant bit rate): 以固定速率编码 </p>
<p>VBR: (variable bit rate): 视频编码速率随 时间的变化而变化</p>
</blockquote>
<h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p>DASH: Dynamic, Adaptive Streaming over HTTP        动态自适应</p>
<p>服务器:<br>将视频文件<strong>分割成多个块</strong>  （流化）<br>每个块独立存储，<strong><u>编码于不同码率（8-10种）</u></strong><br><strong><u>告示文件（manifest file）: 提供不同块的URL</u></strong>    （自适应：自己选择）</p>
<p>客户端:<br> 先获取告示文件<br> 周期性地测量服务器到客户端的带宽<br> 查询告示文件,在一个时刻请求一个块，HTTP头部指定字 节范围<br>        如果带宽足够，选择最大码率的视频块<br>        会话中的不同时刻，可以切换请求不同的编码块 (取 决于当时的可用带宽)</p>
<p>“智能”客户端: 客户端自适应决定 </p>
<ul>
<li>什么时候去请求块 (不至于缓存挨饿，或者溢出) </li>
<li><u><strong>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块)</strong></u> </li>
<li>哪里去请求块 (可以向离自己近的服务器发送URL，或 者向高可用带宽的服务器请求) </li>
</ul>
<p>挑战: 服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)?</p>
<h4 id="选择1-单个的、大的超级服务中心“megaserver”"><a href="#选择1-单个的、大的超级服务中心“megaserver”" class="headerlink" title="选择1: 单个的、大的超级服务中心“megaserver”"></a>选择1: 单个的、大的超级服务中心“megaserver”</h4><p>​     服务器到客户端路径上跳数较多，瓶颈链路的带宽 小导致停顿<br>​     “二八规律”决定了网络同时充斥着同一个视频的 多个拷贝，效率低（付费高、带宽浪费、效果差）<br>​     单点故障点，性能瓶颈<br>​     周边网络的拥塞</p>
<p>相当简单，但是这个方法不可扩展</p>
<h4 id="选项2-通过CDN（content-distribution-network），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验-（内容加速服务）"><a href="#选项2-通过CDN（content-distribution-network），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验-（内容加速服务）" class="headerlink" title="选项2: 通过CDN（content distribution network），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验 （内容加速服务）"></a>选项2: 通过CDN（content distribution network），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验 （内容加速服务）</h4><ul>
<li>enter deep: 将CDN服务器<strong>深入到许多接入网</strong> <ul>
<li><strong>更接近用户</strong>，数量多，离用户近，管理困难 </li>
<li>Akamai, 1700个位置 </li>
</ul>
</li>
<li>bring home: <strong>部署在少数(10个左右)关键位置（到用户的跳数较多）</strong>，如将服务器簇安装于POP附近（离若干1stISP POP较近） <ul>
<li>采用租用线路将服务器簇连接起来 </li>
<li>Limelight</li>
</ul>
</li>
</ul>
<p>CDN: <strong>在CDN节点中存储内容的多个拷贝</strong> 让内容靠近用户<br>    e.g. Netflix stores copies of MadMen </p>
<p>用户从CDN中请求内容<strong>（先从原服务器获取告知文件manifest file，自适应选择块）</strong><br>    (域名解析的重定向)重定向到最近的拷贝，请求内容<br>    如果网络路径拥塞，可能选择不同的拷贝</p>
<p><strong>互联网络主机-主机之间的通信作为一种服务向用户提供</strong></p>
<h4 id="OTT-挑战-在拥塞的互联网上复制内容"><a href="#OTT-挑战-在拥塞的互联网上复制内容" class="headerlink" title="OTT 挑战: 在拥塞的互联网上复制内容"></a>OTT 挑战: 在拥塞的互联网上复制内容</h4><p>OTT(互联网公司越过运营商，发展基于开放互联网的各种视频及数据服务业务)，over the top</p>
<ul>
<li>从哪个CDN节点中获取内容？ </li>
<li>用户在网络拥塞时的行为？ </li>
<li>在哪些CDN节点中存储什么内容？</li>
</ul>
<p>案例学习: Netflix</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724103248401.png" alt="image-20210724103248401"></p>
<h2 id="2-8-TCP-套接字编程"><a href="#2-8-TCP-套接字编程" class="headerlink" title="2.8 TCP 套接字编程"></a>2.8 TCP 套接字编程</h2><p>Socket编程</p>
<p>应用进程使用传输层提供的服务能够交换报文，实现应用协议，实现应用<br>    TCP/IP：应用进程使用Socket API访问传输服务<br>    地点：界面上的SAP(Socket） 方式：Socket API<br><strong>目标: 学习如何构建能借助sockets进行通信的C/S应用程序</strong> </p>
<p>socket: <u><strong>分布式应用进程之间的门</strong></u>，传输层协议提供的端到端服务接口</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724104344583.png" alt="image-20210724104344583"></p>
<p>2种传输层服务的socket类型:<br> TCP: 可靠的、<strong><u>字节流</u></strong>的服务<br> UDP: 不可靠（数据UDP数据报）服务</p>
<p>套接字：应用进程与端到端传输协议（TCP或UDP）之间 的门户<br>TCP服务：从一个进程向另一个进程可靠地传输字节流</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>服务器首先运行，等待连接建立</p>
<p>1：服务器进程必须先处于运行状态<br> <strong>创建欢迎socket</strong><br> <strong>和本地端口捆绑</strong><br> 在欢迎socket上<strong>阻塞式等待</strong>接收用户的连接</p>
<p>客户端主动和服务器建立连接：</p>
<p>2：创建客户端本地套接字（隐式捆绑到本地port）<br> 指定服务器<strong>进程的IP地址和端口号</strong>，<strong>与服务器进程连接</strong></p>
<p>3 ：当与客户端连接请求到来时<br><strong>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个新的socket（与欢迎socket不 一样），与客户端通信</strong><br>     允许服务器与多个客户端通信<br>     使用源IP和源端口来区分不同的客户端</p>
<p>4：连接API调用有效时，客户端P与服务器建立了TCP连接</p>
<p>从应用程序的角度<br>TCP在客户端和服务器进程之间 提供了可靠的、字节流（管道）服务</p>
<h3 id="C-S模式的应用样例"><a href="#C-S模式的应用样例" class="headerlink" title="C/S模式的应用样例"></a>C/S模式的应用样例</h3><p>1) 客户端从标准输入装置读 取一行字符，发送给服务 器<br>2) 服务器从socket读取字符<br>3) 服务器将字符转换成大写 ，然后返回给客户端<br>4) 客户端从socket中读取一 行字符，然后打印出来</p>
<p>实际上，这里描述了C-S之间交互的动作次序</p>
<p><strong>数据结构 sockaddr_in</strong><br>IP地址和port捆绑关系的数据结构（标示进程的端节点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="type">short</span> sin_family; <span class="comment">//AF_INET</span></span><br><span class="line">u_short sin_port; <span class="comment">// port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span><span class="comment">// IP address, unsigned long</span></span><br><span class="line"><span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// align 校准</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p><strong>数据结构 hostent</strong><br>域名和IP地址的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span> </span><br><span class="line"><span class="type">char</span> *h_name;	<span class="comment">//域名</span></span><br><span class="line"><span class="type">char</span> **h_aliases;	/别名</span><br><span class="line"><span class="type">int</span> h_addrtype;	</span><br><span class="line"><span class="type">int</span> h_length; <span class="comment">/*地址长度*/</span></span><br><span class="line"><span class="type">char</span> **h_addr_list;	<span class="comment">//IP地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>作为调用域名解析函数时的参数 返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</p>
<h3 id="C-S-socket-交互-TCP"><a href="#C-S-socket-交互-TCP" class="headerlink" title="C/S socket 交互: TCP"></a>C/S socket 交互: TCP</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724125259562.png" alt="image-20210724125259562"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724130333265.png" alt="image-20210724130333265"></p>
<p>系统自己默认使用了bind，自动分配</p>
<p>argv[1] 主机的名字    argv[2] 端口号    argv[0] 程序的名字</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724130359275.png" alt="image-20210724130359275"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724130416518.png" alt="image-20210724130416518"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724130435777.png" alt="image-20210724130435777"></p>
<h2 id="2-9-UDP-套接字编程"><a href="#2-9-UDP-套接字编程" class="headerlink" title="2.9 UDP 套接字编程"></a>2.9 UDP 套接字编程</h2><p>UDP: 在客户端和服务器之间 没有连接<br>• 没有握手<br>• 发送端在<strong>每一个报文中明确地指定目标的IP地址和端口号</strong><br>• 服务器必须从收到的分组中<strong>提取出发送端的IP地址和端口号</strong></p>
<p>UDP: 传送的数据可能乱序，也可能丢失</p>
<p>进程视角看UDP服务    UDP 为客户端和服务器提供<u><strong>不可靠的字节组</strong></u>的传送服务</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724132456460.png" alt="image-20210724132456460"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724141521790.png" alt="image-20210724141521790"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724141558002.png" alt="image-20210724141558002"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724142042144.png" alt="image-20210724142042144"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20210724142103507.png" alt="image-20210724142103507"></p>
<h1 id="第2章：小结"><a href="#第2章：小结" class="headerlink" title="第2章：小结"></a>第2章：小结</h1><p> 应用程序体系结构<br>     客户-服务器  P2P  混合 </p>
<p> 应用程序需要的服务品质描 述:<br>     可靠性、带宽、延时、安全</p>
<p> Internet传输层服务模式<br>         可靠的、面向连接的服务： TCP<br>         不可靠的数据报：UDP </p>
<p> 流行的应用层协议:<br>         HTTP<br>         FTP<br>         SMTP, POP, IMAP<br>         DNS </p>
<p> Socket编程</p>
<p>更重要的：学习协议的知识</p>
<p> 应用层协议报文类型：请求/响应报文：<br>         客户端请求信息或服务<br>         服务器以数据、状态码进 行响应</p>
<p> 报文格式：<br>         首部：关于数据信息的字段<br>         数据：被交换的信息</p>
<p> 控制报文 vs. 数据报文<br>     带内（一个TCP传两种报文）、带外 （两个TCP）<br> 集中式 vs. 分散式<br> 无状态 vs. 维护状态<br> 可靠的 vs. 不可靠的报文传输<br> 在网络边缘处理复杂性</p>
<p>一个协议定义了在两个或多个通信实体之间交换报文的格式和 次序、以及就一条报文传输和接收或其他事件采取的动作</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AB%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AB%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络第八层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 19:02:36 / 修改时间：19:02:19" itemprop="dateCreated datePublished" datetime="2022-06-29T19:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络第八章"><a href="#计算机网络第八章" class="headerlink" title="计算机网络第八章"></a>计算机网络第八章</h1><p>第 8 章 网络安全</p>
<p>本章目标： </p>
<ul>
<li>网络安全原理: <ul>
<li>加密，不仅仅用于机密性 </li>
<li>认证 </li>
<li>报文完整性 </li>
<li>密钥分发 </li>
</ul>
</li>
<li>安全实践: <ul>
<li>防火墙 </li>
<li>各个层次的安全性：应用层，传输层，网络层和链路层</li>
</ul>
</li>
</ul>
<h1 id="8-1-什么是网络安全？"><a href="#8-1-什么是网络安全？" class="headerlink" title="8.1 什么是网络安全？"></a>8.1 什么是网络安全？</h1><p><strong>机密性</strong>: 只有发送方和预订的接收方能否理解传输的报文内容 </p>
<ul>
<li>发送方加密报文 </li>
<li>接收方解密报文</li>
</ul>
<p><strong>认证</strong>: 发送方和接收方需要<strong>确认对方的身份</strong> </p>
<p><strong>报文完整性</strong>: 发送方、接受方需要<strong>确认报文在传输的过程中或者事后没有被改变</strong> </p>
<p><strong>访问控制和服务的可用性</strong>: 服务可以接入 以及 对用户而言是可用的</p>
<h2 id="朋友和敌人-Alice-Bob-Trudy"><a href="#朋友和敌人-Alice-Bob-Trudy" class="headerlink" title="朋友和敌人: Alice, Bob, Trudy"></a>朋友和敌人: Alice, Bob, Trudy</h2><p>网络安全世界比较著名的模型 </p>
<ul>
<li>Bob, Alice (lovers!) 需要安全的通信 </li>
<li>Trudy (intruder) 可以截获，删除和增加报文</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003150436208.png" alt="image-20211003150436208"></p>
<h2 id="网络中的坏蛋"><a href="#网络中的坏蛋" class="headerlink" title="网络中的坏蛋"></a>网络中的坏蛋</h2><p>Q: “bad guy”可以干什么?</p>
<p>A: 很多!</p>
<ul>
<li>窃听: 截获报文 </li>
<li>插入：在连接上插入报文 </li>
<li>伪装: 可以在分组的源地址写上伪装的地址 </li>
<li>劫持: 将发送方或者接收方踢出，接管连接 </li>
<li>拒绝服务: 阻止服务被其他正常用户使用 (e.g.,通过 对资源的过载使用)</li>
<li>……</li>
</ul>
<h2 id="谁有可能是Bob-Alice"><a href="#谁有可能是Bob-Alice" class="headerlink" title="谁有可能是Bob, Alice?"></a>谁有可能是Bob, Alice?</h2><ul>
<li>… 现实世界中的Bobs和Alices! </li>
<li>电子交易中的Web browser/server (e.g.,在线 购买) </li>
<li>在线银行的client/server </li>
<li>DNS servers </li>
<li>路由信息的交换 </li>
<li>其它例子?</li>
</ul>
<h1 id="8-2-加密原理"><a href="#8-2-加密原理" class="headerlink" title="8.2 加密原理"></a>8.2 加密原理</h1><h2 id="加密语言"><a href="#加密语言" class="headerlink" title="加密语言"></a>加密语言</h2><ul>
<li>plaintext  纯文本<br>ciphertext  密文</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003150803167.png" alt="image-20211003150803167"></p>
<ul>
<li><p>对称密钥密码学: 发送方和接收方的密钥相同 </p>
</li>
<li><p>公开密钥密码学: 发送方使用接收方的公钥进行加密，接收 方使用自己的私钥进行解密</p>
</li>
</ul>
<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003150833540.png" alt="image-20211003150833540"></p>
<p>对称密钥密码: Bob和Alice共享一个对称式的密钥: K </p>
<ul>
<li>e.g., 密钥在单码替换加密方法中是替换模式 </li>
<li>Q: 但是Bob和Alice如何就这个密钥达成一致呢?</li>
</ul>
<p>替换密码: 将一个事情换成另外一个事情</p>
<ul>
<li><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003153247440.png" alt="image-20211003153247440"></li>
</ul>
<p>Q: 破解这个密码的强度? </p>
<ul>
<li>brute force (how hard?) </li>
<li>other?</li>
</ul>
<h2 id="对称密钥加密学-DES"><a href="#对称密钥加密学-DES" class="headerlink" title="对称密钥加密学: DES"></a>对称密钥加密学: DES</h2><p><strong>DES: Data Encryption Standard</strong></p>
<ul>
<li>US 加密标准[NIST 1993] </li>
<li>56-bit 对称密钥, 64-bit明文输入 </li>
<li>DES有多安全? <ul>
<li>DES挑战: 56-bit密钥加密的短语 (“Strong cryptography makes the world a safer place”) 被解密，用了4个月的时间 </li>
<li>可能有后门 </li>
</ul>
</li>
<li>使DES更安全: <ul>
<li><strong>使用3个key， 3重DES 运算</strong> </li>
<li><strong>密文分组成串技术</strong></li>
</ul>
</li>
</ul>
<p>DES operation</p>
<p>初始替换<br>16 轮一样的函数应用 ，每一轮使用的不 同的48bit密钥<br>最终替换</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003153512416.png" alt="image-20211003153512416"></p>
<h2 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h2><ul>
<li><strong>一个循环：一个 输入bit影响8个 输出bit</strong></li>
<li><strong>多重循环: 每个输入比特影响所有的输出bit</strong> </li>
<li><strong>块密码：DES, 3DES, AES</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003153728247.png" alt="image-20211003153728247"></p>
<h2 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES: Advanced Encryption Standard"></a>AES: Advanced Encryption Standard</h2><ul>
<li><strong>新的对称密钥NIST标准(Nov. 2001) 用于替换 DES</strong> </li>
<li><strong>数据128bit成组加密</strong> </li>
<li><strong>128, 192, or 256 bit keys</strong> </li>
<li><strong>穷尽法解密如果使用1秒钟破解 DES, 需要花 149万亿年破解AES</strong></li>
</ul>
<h2 id="密码块链"><a href="#密码块链" class="headerlink" title="密码块链"></a>密码块链</h2><ul>
<li>密码块：如果输入 块重复，将会得到 相同的密文块</li>
<li>密码块链： 异或第i轮 输入 m(i), 与前一轮的密文, c(i-1)   —— <strong>与之前所有的 输入和原文 都有关系</strong><ul>
<li>c(0) 明文传输到接收端 </li>
<li>what happens in “HTTP/1.1” scenario from above?</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003154039265.png" alt="image-20211003154039265"></p>
<h2 id="公开密钥密码学"><a href="#公开密钥密码学" class="headerlink" title="公开密钥密码学"></a>公开密钥密码学</h2><blockquote>
<p>对称密钥密码学</p>
<ul>
<li>需要发送方和接收方对共享式对称密钥达成一 致 </li>
<li>Q: 但是他们如何第一次达成一致 (特别是他们永远不可能见面的情况下 )?</li>
</ul>
</blockquote>
<p><strong>公开密钥密码学</strong></p>
<ul>
<li><strong>完全不同的方法 [Diffie-Hellman76, RSA78]</strong> </li>
<li><strong>发送方和接收方无需共享密钥</strong> </li>
<li><strong>一个实体的公钥公诸于众</strong> </li>
<li><strong>私钥只有他自己知道</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003154754817.png" alt="image-20211003154754817"></p>
<h2 id="公开密钥加密算法"><a href="#公开密钥加密算法" class="headerlink" title="公开密钥加密算法"></a>公开密钥加密算法</h2><p>要求:</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003154439175.png" alt="image-20211003154439175"></p>
<h2 id="RSA-选择密钥"><a href="#RSA-选择密钥" class="headerlink" title="RSA: 选择密钥"></a>RSA: 选择密钥</h2><p><strong>RSA: Rivest, Shamir, Adelson algorithm</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003155140347.png" alt="image-20211003155140347"></p>
<h2 id="RSA-加密-解密"><a href="#RSA-加密-解密" class="headerlink" title="RSA: 加密,解密"></a>RSA: 加密,解密</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003155309450.png" alt="image-20211003155309450"></p>
<h2 id="RSA-为什么"><a href="#RSA-为什么" class="headerlink" title="RSA: 为什么"></a>RSA: 为什么</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003155357026.png" alt="image-20211003155357026"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003155402400.png" alt="image-20211003155402400"></p>
<h2 id="RSA-例子"><a href="#RSA-例子" class="headerlink" title="RSA 例子:"></a>RSA 例子:</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003155453495.png" alt="image-20211003155453495"></p>
<h2 id="RSA-数字签名-——-先解密（私钥）-在加密（公钥）-确认身份"><a href="#RSA-数字签名-——-先解密（私钥）-在加密（公钥）-确认身份" class="headerlink" title="RSA: 数字签名  —— 先解密（私钥） 在加密（公钥） 确认身份"></a>RSA: 数字签名  —— 先解密（私钥） 在加密（公钥） 确认身份</h2><p>下面的特性将在后面非常有用</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003160213019.png" alt="image-20211003160213019"></p>
<p>结果一致!</p>
<p>解密的几种类型</p>
<ul>
<li>加密算法已知，求密钥 </li>
<li>加密算法和密钥均不知道</li>
<li>唯密文攻击</li>
<li>已知明文攻击<ul>
<li>已经知道部分密文和明文的对应关系</li>
</ul>
</li>
<li>选择明文攻击<ul>
<li>攻击者能够选择一段明文，并得到密文</li>
</ul>
</li>
</ul>
<h1 id="8-3-认证"><a href="#8-3-认证" class="headerlink" title="8.3 认证"></a>8.3 认证</h1><ul>
<li>目标: Bob需要Alice证明她的身份</li>
<li>Protocol ap1.0: Alice说“I am Alice”</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003160558153.png" alt="image-20211003160558153"></p>
<p>在网络上Bob看不到 Alice, 因此Trudy可以简单地声称她是 Alice</p>
<h2 id="认证-重新尝试"><a href="#认证-重新尝试" class="headerlink" title="认证:重新尝试"></a>认证:重新尝试</h2><ul>
<li><strong>Protocol ap2.0: Alice 说 “I am Alice” ，在她发送的IP数据包 中包括了她的IP地址</strong><ul>
<li><strong>Trudy可以生成一 个分组，包括伪造 的Alice的地址</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003160759410.png" alt="image-20211003160759410"></p>
<ul>
<li><strong>Protocol ap3.0: Alice 说 “I am Alice” ，而且传送她的密码来证明.</strong><ul>
<li>重放攻击playback attack: Trudy记录 Alice 的 分组，事后向Bob重放</li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003160937998.png" alt="image-20211003160937998"></p>
<ul>
<li><p><strong>Protocol ap3.1: Alice 说 “I am Alice” ，而且传送她的加密之后的密码来证明</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003162002392.png" alt="image-20211003162002392"></p>
</li>
</ul>
<h2 id="目标-避免重放攻击"><a href="#目标-避免重放攻击" class="headerlink" title="目标: 避免重放攻击"></a>目标: 避免重放攻击</h2><ul>
<li><strong>Nonce: 一生只用一次的整数 (R)</strong>  —— <strong>一次性随机数(nonce):一个生命周期内只用1次的数R.</strong> </li>
<li><strong>==ap4.0: 为了证明Alice的活跃性, Bob发送给Alice一个nonce, R. Alice 必须返回加密之后的R，使用双方约定好的key==</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003161055230.png" alt="image-20211003161055230"></p>
<p>这个协议的缺点是需要共享秘钥！ </p>
<h2 id="认证-ap5-0"><a href="#认证-ap5-0" class="headerlink" title="认证: ap5.0"></a>认证: ap5.0</h2><p>ap4.0 需要双方共享一个对称式的密钥 </p>
<ul>
<li>是否可以通过公开密钥技术进行认证呢?</li>
</ul>
<p>ap5.0: 使用nonce,公开密钥加密技术</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003162046298.png" alt="image-20211003162046298"></p>
<h2 id="ap5-0-安全漏洞-——-中间攻击"><a href="#ap5-0-安全漏洞-——-中间攻击" class="headerlink" title="ap5.0: 安全漏洞 —— 中间攻击"></a>ap5.0: 安全漏洞 —— 中间攻击</h2><p>中间攻击: Trudy 在 Alice (to Bob)和 Bob之间 (to Alice)</p>
<p><strong>Trudy 用自己的私钥加密   R</strong><br><strong>传给Bob 公钥</strong></p>
<p><strong>Trudy 截获 Alice 的信息 和 公钥，用Alice 的 公钥 解密 她的 私钥</strong></p>
<p><strong>Bob 与 Alice 之间的信息全被 Trudy 截获</strong> </p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003162123200.png" alt="image-20211003162123200"></p>
<p>==<strong>1、怎样可靠地拿到一个实体的公钥 —— 公开密钥</strong>==<br>==<strong>2、拿到公钥之后怎样验证对方的身份 —— 利用对称密钥</strong>==</p>
<h1 id="8-4-报文完整性"><a href="#8-4-报文完整性" class="headerlink" title="8.4 报文完整性"></a>8.4 报文完整性</h1><h2 id="ap5-0-安全漏洞"><a href="#ap5-0-安全漏洞" class="headerlink" title="ap5.0: 安全漏洞"></a>ap5.0: 安全漏洞</h2><p>中间攻击: Trudy 在 Alice (to Bob)和 Bob之间 (to Alice)</p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003165035508.png" alt="image-20211003165035508"></p>
<ul>
<li>难以检测: <ul>
<li>Bob收到了Alice发送的所有报文, 反之亦然. (e.g., so Bob, Alice一个星期以后相见，回忆起以前的会话) </li>
<li>问题时Trudy也接收到了所有的报文!</li>
</ul>
</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名类比于手写签名</p>
<ul>
<li>发送方 (Bob) 数字签署了文件, 前提是他(她)是文件 的拥有者/创建者. </li>
<li><strong>==可验证性，不可伪造性，不可抵赖性==</strong> <ul>
<li>谁签署：接收方 (Alice)可以向他人证明 是 Bob, 而不是其他 人签署了这个文件 (包括Alice) </li>
<li>签署了什么：这份文件，而不是其它文件</li>
</ul>
</li>
</ul>
<h2 id="简单的对m的数字签名："><a href="#简单的对m的数字签名：" class="headerlink" title="简单的对ｍ的数字签名："></a>简单的对ｍ的数字签名：</h2><ul>
<li><strong>==Bob使用他自己的私钥对m进行了签署 ，创建数字签名 K~B~ (m)==</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003165303684.png" alt="image-20211003165303684"></p>
<h2 id="报文摘要"><a href="#报文摘要" class="headerlink" title="报文摘要"></a>报文摘要</h2><p><strong>==对长报文进行公开密钥加密 算法的实施需要耗费大量的时间==</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211003165506312.png" alt="image-20211003165506312"></p>
<ul>
<li><p><strong>Goal: 固定长度，容易计算的 “fingerprint”</strong> </p>
<ul>
<li>对m使用散列函数H，获得 固定长度的 报文摘要 H(m).</li>
</ul>
</li>
<li><p><strong>散列函数的特性：</strong></p>
<ul>
<li><strong>多对1</strong> </li>
<li><strong>结果固定长度</strong> </li>
<li><strong>给定一个报文摘要x, 反向计算出原报文在计算上是不可行的x = H(m)</strong></li>
</ul>
</li>
</ul>
<ul>
<li>假设Alice收到报文m, 以及数字签名KB (m) </li>
<li>Alice 使用Bob的公钥KB 对KB (m)进行验证， 判断 KB (KB (m) ) = m是否成立. </li>
<li>如 KB (KB (m) ) = m成立, 那么签署这个文件的人一定拥有 Bob的私钥. + + - - -</li>
</ul>
<p><strong>Alice 可以验证:</strong> —— 只有Bob有自己的私钥</p>
<ul>
<li>Bob 签署了m.</li>
<li>不是其他人签署了m. </li>
<li>Bob签署了m 而不是m’.</li>
</ul>
<p><strong>不可抵赖性:</strong></p>
<ul>
<li>Alice可以拿着m,以及数字签名KB (m)到法庭上， 来证明是Bob签署了这个文件 m. </li>
</ul>
<h2 id="Internet校验和-弱的散列函数-（容易冲突）"><a href="#Internet校验和-弱的散列函数-（容易冲突）" class="headerlink" title="Internet校验和: 弱的散列函数 （容易冲突）"></a>Internet校验和: 弱的散列函数 （容易冲突）</h2><p>Internet 校验和拥有一些散列函数的特性:</p>
<ul>
<li>产生报文m的固定长度的摘要 (16-bit sum) </li>
<li>多对1的</li>
</ul>
<p>但是给定一个散列值，很容易计算出另外一个报文具有同样的散列值: </p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004154803194.png" alt="image-20211004154803194"></p>
<h2 id="数字签名-对报文摘要进行数字签署"><a href="#数字签名-对报文摘要进行数字签署" class="headerlink" title="数字签名 = 对报文摘要进行数字签署"></a>数字签名 = 对报文摘要进行数字签署</h2><p><strong>Bob 发送数字签名的报文:</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004154826294.png" alt="image-20211004154826294"></p>
<p><strong>Alice校验签名和报文完整性:</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004154853225.png" alt="image-20211004154853225"></p>
<h1 id="8-5-密钥分发和证书"><a href="#8-5-密钥分发和证书" class="headerlink" title="8.5 密钥分发和证书"></a>8.5 密钥分发和证书</h1><h2 id="散列函数算法"><a href="#散列函数算法" class="headerlink" title="散列函数算法"></a>散列函数算法</h2><ul>
<li>MD5散列函数(RFC 1321)被广泛地应用 <ul>
<li>4个步骤计算出128-bit的报文摘要 </li>
<li>给定一个任意的128-bit串x, 很难构造出一个报文m 具有相同的摘要x.</li>
</ul>
</li>
<li>SHA-1也被使用.<ul>
<li>US标准 [NIST, FIPS PUB 180-1] </li>
<li>160-bit报文摘要</li>
</ul>
</li>
</ul>
<h2 id="可信赖中介"><a href="#可信赖中介" class="headerlink" title="可信赖中介"></a>可信赖中介</h2><h3 id="对称密钥问题"><a href="#对称密钥问题" class="headerlink" title="对称密钥问题"></a>对称密钥问题</h3><ul>
<li>相互通信的实体如何分享对<br>称式的密钥?</li>
</ul>
<p>解决办法: —— 可信赖中介</p>
<ul>
<li><strong>trusted key distribution center (KDC) 在实体之间扮演可信赖中介的角色</strong></li>
</ul>
<h3 id="公共密钥问题-——-可信赖的CA-证书"><a href="#公共密钥问题-——-可信赖的CA-证书" class="headerlink" title="公共密钥问题 —— 可信赖的CA 证书"></a>公共密钥问题 —— 可信赖的CA 证书</h3><ul>
<li>当Alice获得Bob的公钥 (from web site, e-mail, diskette), 她如何知道就 是Bob的public key, 而不 是Trudy的?</li>
</ul>
<p>解决办法: </p>
<ul>
<li><strong>可信赖的certification authority (CA)</strong></li>
</ul>
<h2 id="Key-Distribution-Center-KDC"><a href="#Key-Distribution-Center-KDC" class="headerlink" title="Key Distribution Center (KDC)"></a>Key Distribution Center (KDC)</h2><ul>
<li><strong>Alice, Bob 需要分享对称式密钥。</strong></li>
<li><strong>KDC: 服务器和每一个注册用户都分享一个对称式的密钥 (many users)</strong> </li>
<li><strong>Alice, Bob在和KDC通信的时候，知道他们自己的对称式 密钥 KA-KDC、KB-KDC.</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004155311056.png" alt="image-20211004155311056"></p>
<p><strong>==共享R1，使用R1作为对称式的会话密钥==</strong></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004160353350.png" alt="image-20211004160353350"></p>
<h2 id="Certification-Authorities"><a href="#Certification-Authorities" class="headerlink" title="Certification Authorities"></a>Certification Authorities</h2><ul>
<li><p><strong>Certification authority (CA): 将每一个注册实体E和他的公钥捆绑.</strong></p>
</li>
<li><p>E (person, router) 到CA那里注册他的公钥. </p>
<ul>
<li>E 提供给CA，自己身份的证据 “proof of identity” </li>
<li>CA创建一个证书，捆绑了 实体信息和他的公钥. </li>
<li><strong>Certificate包括了E的公钥，而且是被CA签署的（被CA用自己的私钥加了密的） – CA说 “this is E’s public key”</strong></li>
</ul>
</li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004160749518.png" alt="image-20211004160749518"></p>
<p>当Alice需要拿到Bob公钥 </p>
<ul>
<li><strong>获得Bob的证书certificate (从Bob或者其他地方).</strong> </li>
<li><strong>对Bob的证书，使用CA的公钥来验证</strong></li>
</ul>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004160830345.png" alt="image-20211004160830345"></p>
<h3 id="证书包括"><a href="#证书包括" class="headerlink" title="证书包括:"></a>证书包括:</h3><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004160852343.png" alt="image-20211004160852343"></p>
<h1 id="8-6-各个层次的安全性"><a href="#8-6-各个层次的安全性" class="headerlink" title="8.6 各个层次的安全性"></a>8.6 各个层次的安全性</h1><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163043220.png" alt="image-20211004163043220"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163051600.png" alt="image-20211004163051600"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163104288.png" alt="image-20211004163104288"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163120882.png" alt="image-20211004163120882"></p>
<h2 id="SSL-3阶段"><a href="#SSL-3阶段" class="headerlink" title="SSL: 3阶段"></a>SSL: 3阶段</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163149121.png" alt="image-20211004163149121"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163133733.png" alt="image-20211004163133733"></p>
<p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163207264.png" alt="image-20211004163207264"></p>
<h2 id="IPsec-网络层次的安全性"><a href="#IPsec-网络层次的安全性" class="headerlink" title="IPsec: 网络层次的安全性"></a>IPsec: 网络层次的安全性</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163238244.png" alt="image-20211004163238244"></p>
<h2 id="ESP-协议"><a href="#ESP-协议" class="headerlink" title="ESP 协议"></a>ESP 协议</h2><p><img src="http://knight777.oss-cn-beijing.aliyuncs.com/img/image-20211004163251925.png" alt="image-20211004163251925"></p>
<p>8.6 访问控制：防火墙 </p>
<p>8.7 攻击和对策</p>
<h1 id="网络安全-总结"><a href="#网络安全-总结" class="headerlink" title="网络安全 (总结)"></a>网络安全 (总结)</h1><ul>
<li>基本原理 <ul>
<li>加密 (对称和公开) </li>
<li>报文完整性 </li>
<li>端节点的认证（鉴别） </li>
</ul>
</li>
<li>在多种安全场景中使用 <ul>
<li>安全电子邮件 </li>
<li>安全传输层 (SSL) </li>
<li>IP sec </li>
<li>802.11 </li>
</ul>
</li>
<li><strong>运行中的安全性: firewalls and IDS</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E7%9A%B1%E5%AF%85%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E7%9A%B1%E5%AF%85%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">邹寅英语语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 17:30:27 / 修改时间：17:30:08" itemprop="dateCreated datePublished" datetime="2022-06-29T17:30:27+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index"><span itemprop="name">English</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>四级不考纯语法</strong>，但是听读写译都涉及语法知识<br>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/29/%E7%9A%B1%E5%AF%85%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">数学学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 16:47:40 / 修改时间：17:09:26" itemprop="dateCreated datePublished" datetime="2022-06-29T16:47:40+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>35 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>高等数学—插本数学</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/29/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/4%E7%BA%A7%E8%AF%8D%E6%B1%87%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baozi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1205">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/4%E7%BA%A7%E8%AF%8D%E6%B1%87%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">CET-4 词汇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 15:02:36 / 修改时间：16:53:24" itemprop="dateCreated datePublished" datetime="2022-06-29T15:02:36+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index"><span itemprop="name">English</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CET-4-词汇"><a href="#CET-4-词汇" class="headerlink" title="CET-4    词汇"></a>CET-4    词汇</h1><ul>
<li>发音辅助记忆</li>
<li>生活中的英语</li>
<li>形近词</li>
<li>词源词根词缀法</li>
<li>词以类记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/29/4%E7%BA%A7%E8%AF%8D%E6%B1%87%E5%AD%A6%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Baozi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Baozi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">140k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:07</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
